Sigma.star.inv <- lapply(1:t, make.Sigma.inv, Sigma = Sigma.star)
mh.epsilon.1 <-	sum(sapply(1:t, make.mh, beta = beta, Sigma = Sigma.star, Sigma.inv = Sigma.star.inv)) + dinvgamma(sigma.squared.epsilon.star, alpha.epsilon, beta.epsilon, log = TRUE)
mh.epsilon.2 <- sum(sapply(1:t, make.mh, beta = beta, Sigma = Sigma, Sigma.inv = Sigma.inv)) + dinvgamma(sigma.squared.epsilon, alpha.epsilon, beta.epsilon, log = TRUE)
mh.epsilon <- exp(mh.epsilon.1 - mh.epsilon.2)
if(mh.epsilon > runif(1)){
sigma.squared.epsilon <- sigma.squared.epsilon.star
Sigma.epsilon <- Sigma.epsilon.star
Sigma.epsilon.inv <- Sigma.epsilon.star.inv
Sigma <- Sigma.star
Sigma.inv <- Sigma.star.inv
epsilon.accept <- epsilon.accept + 1 / n.mcmc
}
rm(Sigma.epsilon.star)
rm(Sigma.epsilon.star.inv)
rm(Sigma.star)
rm(Sigma.star.inv)
}
rm(sigma.squared.epsilon.star)
phi.star <- rnorm(1, phi, phi.tune)
R.list.star <- lapply(1:t, make.R.list, sigma.squared.eta = sigma.squared.eta, phi = phi.star, D.list = D.list)
Sigma.star <- lapply(1:t, make.Sigma, R.list = R.list.star, Sigma.epsilon = Sigma.epsilon)
Sigma.star.inv <- lapply(1:t, make.Sigma.inv, Sigma = Sigma.star)
phi.tune <- 0.25
phi.star <- rnorm(1, phi, phi.tune)
R.list.star <- lapply(1:t, make.R.list, sigma.squared.eta = sigma.squared.eta, phi = phi.star, D.list = D.list)
Sigma.star <- lapply(1:t, make.Sigma, R.list = R.list.star, Sigma.epsilon = Sigma.epsilon)
Sigma.star.inv <- lapply(1:t, make.Sigma.inv, Sigma = Sigma.star)
phi.star
mh.phi.1 <-	sum(sapply(1:t, make.mh, beta = beta, Sigma = Sigma.star, Sigma.inv = Sigma.star.inv)) + dinvgamma(phi.star, alpha.phi, beta.phi, log = TRUE)
mh.phi.2 <- sum(sapply(1:t, make.mh, beta = beta, Sigma = Sigma, Sigma.inv = Sigma.inv)) + dinvgamma(phi, alpha.phi, beta.phi, log = TRUE)
mh.phi <- exp(mh.phi.1 - mh.phi.2)
mh.phi
phi
phi.star
source('~/1dSpatialSim/mcmc.spatial.R')
rm(list = ls())
##
## Libraries and Subroutines
##
library(geoR)
#library(gstat)
library(mvtnorm)
library(gplots)
set.seed(101)
## make true spatial field
make.field <- function(t, mu, Sig.s, m){
mu + t(chol(Sig.s)) %*% rnorm(m)
}
## make sampling matrix H.list
make.H.list <- function(t, samp, m){
(1:m)[samp[[t]]]
}
## make sample data Y.list
make.Y.list <- function(t, Z, H.list, s2.e = 1){
Z[, t][H.list[[t]]] + rnorm(length(H.list[[t]]), s2.e)
}
## make sample spatial covaraites X.list
make.X.list <- function(s, X, H.list){
X[H.list[[s]], ]
}
make.krige.fit <- function(t, Y.list, H.list, locs){
Y.geo <- as.geodata(cbind(Y.list[[t]], locs[H.list[[t]]],
rep(0, length(H.list[[t]]))), coords.col = 2:3, data.col = 1)
Y.geo.var <- variog(Y.geo, ini.cov.pairs = c(1, 2), trend = '1st',
max.dist = 0.75, messages = FALSE)
Y.geo.fit <- variofit(Y.geo.var, messages = FALSE, cov.model = 'exponential',
weights = 'cressie', fix.nugget = TRUE, nugget = 0, fix.kappa = TRUE, kappa = 0)
return(Y.geo.fit)
}
make.pred <- function(t, Y.list, H.list, mu, Sig){
pred <- vector(length = m)
pred[ - H.list[[t]]] <- mu[ - H.list[[t]]] + Sig[[t]][ - H.list[[t]], H.list[[t]]] %*%
solve(Sig[[t]][H.list[[t]], H.list[[t]]]) %*% (Y.list[[t]] - mu[H.list[[t]]])
pred[H.list[[t]]] <- Y.list[[t]]
return(pred)
}
plot.field <- function(Y.list, H.list, locs){
t <- length(Y.list)
min.Y <- min(unlist(lapply(Y.list, min)))
max.Y <- max(unlist(lapply(Y.list, max)))
idx <- order(locs[H.list[[1]]])
plot(Y.list[[1]][idx] ~ locs[H.list[[1]]][idx], type = 'l', ylim = c(min.Y, max.Y), main = "Observed Data")
for(i in 2:t){
idx <- order(locs[H.list[[i]]])
lines(Y.list[[i]][idx] ~ locs[H.list[[i]]][idx], type = 'l', col = i)
}
}
####
####  Simulate 1-D spatial random fields with trend
####
m <- 1000 # number of spatial locations
locs <- seq(0, 1, , m) # spatial coordinate
t <- 100 # number of spatial fields
X <- cbind(rep(1, m), locs)
beta <- c(0, 2) # beta
mu <- X %*% beta # mean function
##
## Exponentail Spatial Decay Function s2.s * exp( - D / phi)
##
s2.s <- 1 # spatial variance parameter
phi <- 15 # spatial decay for exponential
D <- as.matrix(dist(locs)) # distance matrix
Sig.s <- s2.s * exp( - D / phi) # spatial covariance matrix
Sig.s.inv <- solve(Sig.s)
##
## Simulate Random Field without nugget
##
Z <- sapply(1:t, make.field, mu = mu, Sig.s = Sig.s, m = m)
##
## Image full data
##
matplot(Z, type = "l", lty = 1, main = "1-D Spatial Field")
##
## Krige the full data
##
## Assume stationarity and anisotropy
Z.geo <- list(length = t)
Z.geo.var <- list(length = t)
Z.geo.fit <- list(length = t)
for(i in 1:t){
Z.geo[[i]] <- as.geodata(cbind(Z[, i], locs, rep(0, m)), coords.col = 2:3, data.col = 1)
Z.geo.var[[i]] <- variog(Z.geo[[i]], ini.cov.pairs = c(1, 2), trend = '1st',
max.dist = 0.75, messages = FALSE)
Z.geo.fit[[i]] <- variofit(Z.geo.var[[i]], messages = FALSE, cov.model = 'exponential',
weights = 'cressie', fix.nugget = TRUE, nugget = 0, fix.kappa = TRUE, kappa = 0)
}
## Plot Semivariogram
for(i in 1:t){
plot(Z.geo.var[[i]])
lines(Z.geo.fit[[i]])
}
s2.fit <- vector(length = t)
phi.fit <- vector(length = t)
Sig.s.fit <- vector('list', length = t)
for(i in 1:t){
s2.fit[i] <- summary(Z.geo.fit[[i]])$spatial.component[1]
phi.fit[i] <- summary(Z.geo.fit[[i]])$spatial.component[2]
Sig.s.fit[[i]] <- s2.fit[i] * exp( - D / phi.fit[s])
}
####
####  Subsample Fields and Create Data Matrix
####
s2.e <- 0.01 # sampling error
# samp.size <- sample(140:200, t, replace = TRUE) # sample size varies
samp.size <- sample(40:200, 1, replace = TRUE) # sample size consistent <- needed for mcmc.spatial
samp <- vector('list', length = t)
for(i in 1:t){
#samp[[i]] <- sample(1:m, samp.size[[i]])
samp[[i]] <- sample(1:m, samp.size)
}
H.list <- lapply(1:t, make.H.list, samp = samp, m = m)
Y.list <- lapply(1:t, make.Y.list, Z = Z, H.list = H.list, s2.e = s2.e)
X.list <- lapply(1:t, make.X.list, X, H.list)
plot.field(Y.list = Y.list, H.list = H.list, locs = locs)
dinvgamma = function(x, shape = 1, rate = 1, scale = 1/rate, log = FALSE) {
# return( rate^shape / gamma(shape) * exp( - rate / x) * x^( - shape - 1))
logval = shape * log(rate) - lgamma(shape) - rate / x - (shape + 1) * log(x)
if (log)
return(logval)
else
return(exp(logval))
}
make.vector <- function(s, beta, Sigma.inv){
t(Y.list[[s]] - H[[s]] %*% X %*% beta[, s]) %*% (Sigma.inv[[s]]) %*% (Y.list[[s]] - H[[s]] %*% X %*% beta[, s])
}
make.sum.sigma.beta <- function(beta, mu.beta){
temp <- vector(length = t)
for(s in 1:t){
temp[s] <- t(beta[, s] - mu.beta) %*% Sigma.beta.inv %*% (beta[, s] - mu.beta)
}
return(sum(temp))
}
##
## Predictive Process
##
##  make.mh <- function(s, beta, Sigma.epsilon, Sigma.epsilon.inv, Sigma.inv, C.star, C.star.inv, c){
##    ( - t / 2) * (determinant(C.star.inv + c %*% t(H[[s]]) %*% Sigma.epsilon.inv[[s]] %*% H[[s]] %*% t(c), logarithm = TRUE)$modulus[1] +
##      determinant(C.star, logarithm = TRUE)$modulus[1] + determinant(Sigma.epsilon[[s]], logarithm = TRUE)$modulus[1]) -
##     1 / 2 * t(Y.list[[s]] - H[[s]] %*% X %*% beta[, s]) %*% (Sigma.inv[[s]]) %*% (Y.list[[s]] - H[[s]] %*% X %*% beta[, s])
##  }
##  make.c <- function(sigma.squared.eta, phi){
##    sigma.squared.eta * exp( - D.0 / phi)
##  }
##  make.C.star <- function(sigma.squared.eta, phi){
##  	sigma.squared.eta * exp( - D.star / phi)
##  }
##  make.C.star.inv <- function(C.star){
##    solve(C.star)
##  }
##  make.Sigma <- function(s, Sigma.epsilon, C.star, c){
##  	H[[s]] %*% t(c) %*% C.star %*% c %*% t(H[[s]]) + Sigma.epsilon[[s]]
##  }
##  make.Sigma.inv <- function(s, Sigma.epsilon.inv, C.star.inv, c){
##    Sigma.epsilon.inv[[s]] - Sigma.epsilon.inv[[s]] %*% H[[s]] %*% t(c) %*% solve(C.star.inv + c %*% t(H[[s]]) %*% Sigma.epsilon.inv[[s]] %*% H[[s]] %*% t(c)) %*% c %*% t(H[[s]]) %*% Sigma.epsilon.inv[[s]]
##  }
##  make.Sigma.inv <- function(s, Sigma.epsilon.inv, C.star.inv, c){
## 	Sigma.epsilon.inv[[s]] - Sigma.epsilon.inv[[s]] %*% H[[s]] %*% t(c) %*% solve(C.star.inv + c %*% t(H[[s]]) %*% Sigma.epsilon.inv[[s]] %*% H[[s]] %*% t(c)) %*% c %*% t(H[[s]]) %*% Sigma.epsilon.inv[[s]]
## }
make.D.list <- function(s, H.list, locs){
as.matrix(dist(locs[H.list[[s]]]))
}
make.R.list <- function(s, sigma.squared.eta, phi, D.list){
sigma.squared.eta * exp( - D.list[[s]] / phi)
}
make.Sigma.epsilon <- function(s, sigma.squared.epsilon){
if(length(nt) == 1){
sigma.squared.epsilon * diag(nt)
} else {
sigma.squared.epsilon * diag(nt[s])
}
}
make.Sigma.epsilon.inv <- function(s, Sigma.epsilon){
solve(Sigma.epsilon[[s]])
}
make.Sigma <- function(s, R.list, Sigma.epsilon){
R.list[[s]] + Sigma.epsilon[[s]]
}
make.Sigma.inv <- function(s, Sigma){
solve(Sigma[[s]])
}
make.mh <- function(s, beta, Sigma, Sigma.inv){
( - t / 2) * determinant(Sigma[[s]], logarithm = TRUE)$modulus[1] - 1 / 2 * t(Y.list[[s]] - HX.list[[s]] %*% beta[, s]) %*%
Sigma.inv[[s]] %*% (Y.list[[s]] - HX.list[[s]] %*% beta[, s])
}
##  make.fort.batch <- function(s, beta, c, C.star, C.star.inv, sigma.squared.epsilon){#, w.tilde){
##  	w.star <- rmvnorm(1, vec.0, C.star)
##    w.tilde <- t(c) %*% C.star.inv %*% t(w.star)
##  	if(dim(beta)[1] == 1){
##  		X * beta[s] + w.tilde + rnorm(ncells, 0, sigma.squared.epsilon)
##  	} else {
##  		X %*% beta[, s] + w.tilde + rnorm(ncells, 0, sigma.squared.epsilon)
##  	}
##  }
##
## Initialize parameters
##
t <- length(Y.list)
if(is.null(dim(X)) == TRUE){ncells <- length(X)} else {ncells <- dim(X)[1]}
if(is.null(dim(X)) == TRUE){tau <- 1} else {tau <- dim(X)[2]}
nt <- length(Y.list[[1]]) # sample size consistent
## sample size varies
#nt <- c()
#for(s in 1:t){
#	nt[s] <- length(Y.list[[s]])
#}
nt.sum <- sum(nt)
##  n.knots <- length(s.star) # predictive process
## Initialze process
beta <- matrix(0, nrow = tau, ncol = t)
## Initialize parameter model
sigma.squared.beta <- 1 / rgamma(1, alpha.beta, beta.beta)
Sigma.beta <- sigma.squared.beta * diag(tau)
Sigma.beta.inv <- solve(Sigma.beta)
det.Sigma.beta <- determinant(Sigma.beta.inv, logarithm = FALSE)$modulus[1]
##
## Libraries and Subroutines
##
dinvgamma = function(x, shape = 1, rate = 1, scale = 1/rate, log = FALSE) {
# return( rate^shape / gamma(shape) * exp( - rate / x) * x^( - shape - 1))
logval = shape * log(rate) - lgamma(shape) - rate / x - (shape + 1) * log(x)
if (log)
return(logval)
else
return(exp(logval))
}
params = c(mu.0, Sigma.0, alpha.beta, beta.beta, alpha.eta, beta.eta, alpha.epsilon, beta.epsilon, alpha.phi, beta.phi, n.mcmc = 5000)
mu.0 <- rep(0, dim(X)[2])
sigma.squared.0 <- 100
Sigma.0 <-
alpha.beta <- 10
beta.beta <- 10
curve(dinvgamma(x, alpha.beta, beta.beta))
alpha.eta <- 10
beta.eta <- 10
curve(dinvgamma(x, alpha.eta, beta.eta))
alpha.epsilon <- 10
beta.epsilon <- 10
curve(dinvgamma(x, alpha.epsilon, beta.epsilon))
alpha.phi <- 10
beta.phi <- 10
curve(dinvgamma(x, alpha.phi, beta.phi))
n.mcmc <- 5000
sigma.squared.beta.tune <- 0.25
sigma.squared.eta.tune <- 0.25
sigma.squared.epsilon.tune <- 0.25
phi.tune <- 0.25
t <- length(Y.list)
if(is.null(dim(X)) == TRUE){ncells <- length(X)} else {ncells <- dim(X)[1]}
if(is.null(dim(X)) == TRUE){tau <- 1} else {tau <- dim(X)[2]}
nt <- length(Y.list[[1]]) # sample size consistent
## sample size varies
#nt <- c()
#for(s in 1:t){
#	nt[s] <- length(Y.list[[s]])
#}
nt.sum <- sum(nt)
##  n.knots <- length(s.star) # predictive process
## Initialze process
beta <- matrix(0, nrow = tau, ncol = t)
## Initialize parameter model
sigma.squared.beta <- 1 / rgamma(1, alpha.beta, beta.beta)
Sigma.beta <- sigma.squared.beta * diag(tau)
Sigma.beta.inv <- solve(Sigma.beta)
det.Sigma.beta <- determinant(Sigma.beta.inv, logarithm = FALSE)$modulus[1]
sigma.squared.eta <- 1 / rgamma(1, alpha.eta, beta.eta)
phi <- 1 / rgamma(1, alpha.phi, beta.phi)
D <- as.matrix(dist(locs))
D.list <- lapply(1:t, make.D.list, H.list = H.list, locs = locs)
R.list <- lapply(1:t, make.R.list, sigma.squared.eta = sigma.squared.eta, phi = phi, D.list = D.list)
sigma.squared.epsilon <- 1 / rgamma(1, alpha.epsilon, beta.epsilon)
Sigma.epsilon <- vector('list', length = t)
Sigma.epsilon.inv <- vector('list', length = t)
Sigma.epsilon <- lapply(1:t, make.Sigma.epsilon, sigma.squared.epsilon = sigma.squared.epsilon)
Sigma.epsilon.inv <- lapply(1:t, make.Sigma.epsilon.inv, Sigma.epsilon = Sigma.epsilon)
Sigma.0 <- sigma.squared.0 * diag(tau)
Sigma.0.inv <- solve(Sigma.0)
Sigma <- lapply(1:t, make.Sigma, R.list = R.list, Sigma.epsilon = Sigma.epsilon)
Sigma.inv <- lapply(1:t, make.Sigma.inv, Sigma = Sigma)
devs <- rnorm(t)
Sigma.chol <- chol(Sigma.0)
mu.beta <- backsolve(Sigma.chol, backsolve(Sigma.0, mu.0, transpose = TRUE) + devs)
n.burn <- floor(n.mcmc / 10)
fort.raster.batch <- matrix(0, ncells, t)
##  Distance Matrices for Predictive Process
##  D.star <- as.matrix(dist(s.star))
##  D.0 <- matrix(nrow = n.knots, ncol = ncells)
##    for(i in 1:n.knots){
##    for(j in 1:ncells){
##  	  D.0[i, j] <- sqrt((s.star[i] - locs[j])^2)
##  }
tHX.list <- vector('list', length = t)
HX.list <- vector('list', length = t)
for(s in 1:t){
HX.list[[s]] <-   X[H.list[[s]], ]
tHX.list[[s]] <- t(HX.list[[s]])
}
##
## Initialize Storage
##
beta.save <- array(dim = c(tau, t, n.mcmc))
sigma.squared.beta.save <- vector(length = n.mcmc)
sigma.squared.epsilon.save <- vector(length = n.mcmc)
sigma.squared.eta.save <- vector(length = n.mcmc)
phi.save <- vector(length = n.mcmc)
mu.beta.save <- matrix(NA, nrow = tau, ncol = n.mcmc)
fort.raster <- matrix(0, nrow = ncells, ncol = t)
MSPE.save <- 0
var.save <- matrix(0, nrow = ncells, ncol = t)
var.save.temp <- array(dim = c(100, ncells, t))
phi.accept <- 0
eta.accept <- 0
epsilon.accept <- 0
for(s in 1:t){
devs <- rnorm(tau)
beta.A.chol <- ## Calculate t(X) %*% H.list[[s]] once, not in each loop tHX.list andHX.list
if(is.null(dim(H.list[[s]])) == TRUE){
chol(tHX.list[[s]] %*% Sigma.inv[[s]] %*% HX.list[[s]] + Sigma.beta.inv)
} else {
chol(tHX.list[[s]] %*% Sigma.inv[[s]] %*% HX.list[[s]] + Sigma.beta.inv)
}
beta.b <- if(is.null(dim(H.list[[s]])) == TRUE){
tHX.list[[s]] %*% Sigma.inv[[s]] %*% Y.list[[s]] + Sigma.beta.inv %*% mu.beta
} else {
tHX.list[[s]] %*% Sigma.inv[[s]] %*% Y.list[[s]] + Sigma.beta.inv %*% mu.beta
}
beta[, s] <- backsolve(beta.A.chol, backsolve(beta.A.chol, beta.b, transpose = TRUE) + devs)
}
##
## Sample mu.beta
##
devs <- rnorm(tau)
mu.beta.A.chol <- chol(t * Sigma.beta.inv + Sigma.0.inv)
mu.beta.b <- apply(Sigma.beta.inv %*% beta, 1, sum) + Sigma.0.inv %*% mu.0
mu.beta <- backsolve(mu.beta.A.chol, backsolve(mu.beta.A.chol, mu.beta.b, transpose = TRUE) + devs)
## Sample sigma.squared.beta
##
sigma.squared.beta <- 1 / rgamma(1, alpha.beta + t * det.Sigma.beta / 2, 1 / 2 * make.sum.sigma.beta(beta, mu.beta) + beta.beta)
Sigma.beta <- sigma.squared.beta * diag(tau)
Sigma.beta.inv <- solve(Sigma.beta)
##
## Sample sigma.squared.eta
##
sigma.squared.eta.star <- rnorm(1, sigma.squared.eta, sigma.squared.eta.tune)
if(sigma.squared.eta.star > 0){
R.list.star <- lapply(1:t, make.R.list, sigma.squared.eta = sigma.squared.eta.star, phi = phi, D.list = D.list)
Sigma.star <- lapply(1:t, make.Sigma, R.list = R.list.star, Sigma.epsilon = Sigma.epsilon)
Sigma.star.inv <- lapply(1:t, make.Sigma.inv, Sigma = Sigma.star)
mh.eta.1 <- sum(sapply(1:t, make.mh, beta = beta, Sigma = Sigma.star, Sigma.inv = Sigma.star.inv)) + dinvgamma(sigma.squared.eta.star, alpha.eta, beta.eta, log = TRUE)
mh.eta.2 <- sum(sapply(1:t, make.mh, beta = beta, Sigma = Sigma, Sigma.inv = Sigma.inv)) + dinvgamma(sigma.squared.eta, alpha.eta, beta.eta, log = TRUE)
mh <- exp(mh.eta.1 - mh.eta.2)
if(mh > runif(1)){
sigma.squared.eta <- sigma.squared.eta.star
Sigma <- Sigma.star
Sigma.inv <- Sigma.star.inv
eta.accept <- eta.accept + 1 / n.mcmc
}
rm(Sigma.star)
rm(Sigma.star.inv)
}
rm(sigma.squared.eta.star)
##
## Sample sigma.squared.epsilon
##
sigma.squared.epsilon.star <- rnorm(1, sigma.squared.epsilon, sigma.squared.epsilon.tune)
if(sigma.squared.epsilon.star > 0){
Sigma.epsilon.star <- lapply(1:t, make.Sigma.epsilon, sigma.squared.epsilon = sigma.squared.epsilon.star)
Sigma.epsilon.star.inv <- lapply(1:t, make.Sigma.epsilon.inv, Sigma.epsilon = Sigma.epsilon.star)
Sigma.star <- lapply(1:t, make.Sigma, R.list = R.list, Sigma.epsilon = Sigma.epsilon.star)
Sigma.star.inv <- lapply(1:t, make.Sigma.inv, Sigma = Sigma.star)
mh.epsilon.1 <-	sum(sapply(1:t, make.mh, beta = beta, Sigma = Sigma.star, Sigma.inv = Sigma.star.inv)) + dinvgamma(sigma.squared.epsilon.star, alpha.epsilon, beta.epsilon, log = TRUE)
mh.epsilon.2 <- sum(sapply(1:t, make.mh, beta = beta, Sigma = Sigma, Sigma.inv = Sigma.inv)) + dinvgamma(sigma.squared.epsilon, alpha.epsilon, beta.epsilon, log = TRUE)
mh.epsilon <- exp(mh.epsilon.1 - mh.epsilon.2)
if(mh.epsilon > runif(1)){
sigma.squared.epsilon <- sigma.squared.epsilon.star
Sigma.epsilon <- Sigma.epsilon.star
Sigma.epsilon.inv <- Sigma.epsilon.star.inv
Sigma <- Sigma.star
Sigma.inv <- Sigma.star.inv
epsilon.accept <- epsilon.accept + 1 / n.mcmc
}
rm(Sigma.epsilon.star)
rm(Sigma.epsilon.star.inv)
rm(Sigma.star)
rm(Sigma.star.inv)
}
rm(sigma.squared.epsilon.star)
## Sample phi
##
phi.star <- rnorm(1, phi, phi.tune)
if(phi.star > 0){
R.list.star <- lapply(1:t, make.R.list, sigma.squared.eta = sigma.squared.eta, phi = phi.star, D.list = D.list)
Sigma.star <- lapply(1:t, make.Sigma, R.list = R.list.star, Sigma.epsilon = Sigma.epsilon)
Sigma.star.inv <- lapply(1:t, make.Sigma.inv, Sigma = Sigma.star)
mh.phi.1 <-	sum(sapply(1:t, make.mh, beta = beta, Sigma = Sigma.star, Sigma.inv = Sigma.star.inv)) + dinvgamma(phi.star, alpha.phi, beta.phi, log = TRUE)
mh.phi.2 <- sum(sapply(1:t, make.mh, beta = beta, Sigma = Sigma, Sigma.inv = Sigma.inv)) + dinvgamma(phi, alpha.phi, beta.phi, log = TRUE)
mh.phi <- exp(mh.phi.1 - mh.phi.2)
if(mh.phi > runif(1)){
phi <- phi.star
c <- c.star
C.star <- C.star.star
C.star.inv <- C.star.star.inv
Sigma <- Sigma.star
Sigma.inv <- Sigma.star.inv
phi.accept <- phi.accept + 1 / n.mcmc
}
rm(c.star)
rm(C.star.star)
rm(C.star.star.inv)
rm(Sigma.star)
rm(Sigma.star.inv)
}
rm(phi.star)
R.list <- R.list.star
Sigma <- Sigma.star
Sigma.inv <- Sigma.star.inv
phi.star <- rnorm(1, phi, phi.tune)
if(phi.star > 0){
R.list.star <- lapply(1:t, make.R.list, sigma.squared.eta = sigma.squared.eta, phi = phi.star, D.list = D.list)
Sigma.star <- lapply(1:t, make.Sigma, R.list = R.list.star, Sigma.epsilon = Sigma.epsilon)
Sigma.star.inv <- lapply(1:t, make.Sigma.inv, Sigma = Sigma.star)
mh.phi.1 <-	sum(sapply(1:t, make.mh, beta = beta, Sigma = Sigma.star, Sigma.inv = Sigma.star.inv)) + dinvgamma(phi.star, alpha.phi, beta.phi, log = TRUE)
mh.phi.2 <- sum(sapply(1:t, make.mh, beta = beta, Sigma = Sigma, Sigma.inv = Sigma.inv)) + dinvgamma(phi, alpha.phi, beta.phi, log = TRUE)
mh.phi <- exp(mh.phi.1 - mh.phi.2)
if(mh.phi > runif(1)){
phi <- phi.star
R.list <- R.list.star
Sigma <- Sigma.star
Sigma.inv <- Sigma.star.inv
phi.accept <- phi.accept + 1 / n.mcmc
}
rm(R.list.star)
rm(Sigma.star)
rm(Sigma.star.inv)
}
rm(phi.star)
k=1
beta.save[, , k] <- beta
sigma.squared.beta.save[k] <- sigma.squared.beta
sigma.squared.eta.save[k] <- sigma.squared.eta
sigma.squared.epsilon.save[k] <- sigma.squared.epsilon
mu.beta.save[, k] <- mu.beta
phi.save[k] <- phi
}
source('mcmc.spatial.R')
start <-systemTime()
start <-sysTime()
start <-SysTime()
start <-Sys.time()
start <-Sys.time()
out <- mcmc.1d(Y.list, H.list, X, locs, n.mcmc, mu.0, Sigma.0, sigma.squared.beta, sigma.squared.eta, alpha.epsilon, beta.epsilon, alpha.beta, beta.beta, alpha.phi, beta.phi, mu.beta,  s.star, sigma.squared.eta.tune, sigma.squared.epsilon.tune, phi.tune)
source('~/1dSpatialSim/mcmc.spatial.R')
start <-Sys.time()
out <- mcmc.1d(Y.list, H.list, X, locs, n.mcmc, mu.0, Sigma.0, sigma.squared.beta, sigma.squared.eta, alpha.epsilon, beta.epsilon, alpha.beta, beta.beta, alpha.phi, beta.phi, mu.beta,  s.star, sigma.squared.eta.tune, sigma.squared.epsilon.tune, phi.tune)
n.mcmc
n.mcmc <- 100
start <-Sys.time()
out <- mcmc.1d(Y.list, H.list, X, locs, n.mcmc, mu.0, Sigma.0, sigma.squared.beta, sigma.squared.eta, alpha.epsilon, beta.epsilon, alpha.beta, beta.beta, alpha.phi, beta.phi, mu.beta,  s.star, sigma.squared.eta.tune, sigma.squared.epsilon.tune, phi.tune)
finish <- Sys.time() - start
finish
names(out)
layout(matrix(1:8, nrow = 2))
plot(out$sigma.squared.beta.save, type = 'l')
plot(out$sigma.squared.epsilon.save, type = 'l', main = paste("accept rate", out$epsilon.accept))
abline(h = s2.e)
plot(out$sigma.squared.eta.save, type = 'l', main = paste("accept rate", out$eta.accept))
abline(h = s2.s)
matplot(t(out$mu.beta.save), type = 'l')
plot(out$phi.save, type = 'l', main = paste("accept rate", out$phi.accept))
abline(h = phi)
matplot(out$fort.raster, type = 'l')
matplot(Z[, 1:100], type = 'l')
matplot((out$fort.raster - Z[, 1:100])^2, type = 'l')
