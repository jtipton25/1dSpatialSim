pred <- vector(length = m)
pred[ - H.list[[reps]]] <- mu[ - H.list[[reps]]] + Sig.s[ - H.list, H.list] %*%
solve(Sig.s[H.list, H.list]) %*% (Y.list - mu[H.list])
pred[H.list] <- Y.list
return(pred)
}
Z.pred <- lapply(1:reps, make.pred, Y.list = Y.list, H.list = H.list, mu = mu, Sig = Sig)
make.pred <- function(reps, Y.list, H.list, mu, Sig){
pred <- vector(length = m)
pred[ - H.list[[reps]]] <- mu[ - H.list[[reps]]] + Sig.s[[reps]]][ - H.list[[reps]]], H.list[[reps]]]] %*%
solve(Sig.s[[reps]]][H.list[[reps]]], H.list[[reps]]]]) %*% (Y.list[[reps]]] - mu[H.list[[reps]]]])
pred[H.list[[reps]]]] <- Y.list[[reps]]]
return(pred)
}
pred[ - H.list[[reps]]] <- mu[ - H.list[[reps]]] + Sig.s[[reps]]][ - H.list[[reps]]], H.list[[reps]]]] %*%
pred[ - H.list[[reps]]] <- mu[ - H.list[[reps]]] + Sig.s[[reps]][ - H.list[[reps]]], H.list[[reps]]]] %*%
pred[ - H.list[[reps]]] <- mu[ - H.list[[reps]]] + Sig.s[[reps]][ - H.list[[reps]], H.list[[reps]]]] %*%
pred[ - H.list[[reps]]] <- mu[ - H.list[[reps]]] + Sig.s[[reps]][ - H.list[[reps]], H.list[[reps]]] %*%
solve(Sig.s[[reps]]][H.list[[reps]]], H.list[[reps]]]]) %*% (Y.list[[reps]]] - mu[H.list[[reps]]]])
solve(Sig.s[[reps]][H.list[[reps]], H.list[[reps]]]) %*% (Y.list[[reps]] - mu[H.list[[reps]]])
solve(Sig.s[[reps]][H.list[[reps]], H.list[[reps]]]) %*% (Y.list[[reps]] - mu[H.list[[reps]]])
solve(Sig.s[[reps]][H.list[[reps]], H.list[[reps]]])
[H.list[[reps]], H.list[[reps]]]
[H.list[[reps]], H.list[[reps]]
H.list[[reps]], H.list[[reps]]
H.list[[reps]]
Sig.s[[reps]]
str(Sig.s)
make.pred <- function(reps, Y.list, H.list, mu, Sig){
pred <- vector(length = m)
pred[ - H.list[[reps]]] <- mu[ - H.list[[reps]]] + Sig.s[[reps]][ - H.list[[reps]], H.list[[reps]]] %*%
solve(Sig.s[[reps]][H.list[[reps]], H.list[[reps]]])
%*% (Y.list[[reps]] - mu[H.list[[reps]]])
pred[H.list[[reps]]]] <- Y.list[[reps]]]
return(pred)
}
make.pred <- function(reps, Y.list, H.list, mu, Sig){
pred <- vector(length = m)
pred[ - H.list[[reps]]] <- mu[ - H.list[[reps]]] + Sig.s[[reps]][ - H.list[[reps]], H.list[[reps]]] %*%
solve(Sig.s[[reps]][H.list[[reps]], H.list[[reps]]])
%*% (Y.list[[reps]] - mu[H.list[[reps]]])
pred[H.list[[reps]]] <- Y.list[[reps]]
return(pred)
}
make.pred <- function(reps, Y.list, H.list, mu, Sig){
pred <- vector(length = m)
pred[ - H.list[[reps]]] <- mu[ - H.list[[reps]]] + Sig.s[[reps]][ - H.list[[reps]], H.list[[reps]]] %*%
solve(Sig.s[[reps]][H.list[[reps]], H.list[[reps]]]) %*% (Y.list[[reps]] - mu[H.list[[reps]]])
pred[H.list[[reps]]] <- Y.list[[reps]]
return(pred)
}
Z.pred <- lapply(1:reps, make.pred, Y.list = Y.list, H.list = H.list, mu = mu, Sig = Sig)
Z.pred <- lapply(1:reps, make.pred, Y.list = Y.list, H.list = H.list, mu = mu, Sig = Sig.s.fit)
Sig.s.fit[[reps]]
Sig.s.fit <- vector('list', length = reps)
for(t in 1:reps){
s2.fit[[t]] <- summary(Y.geo.fit[[t]])$spatial.component[1]
phi.fit[[t]] <- summary(Y.geo.fit[[t]])$spatial.component[2]
Sig.s.fit[[t]] <- s2.fit[[t]] * exp( - D / phi.fit[[t]])
}
Sig.s.fit[[reps]]
s2.fit
s2.fit[[t]]
s2.fit <- vector(length = reps)
s2.fit <- vector(length = reps)
phi.fit <- vector(length = reps)
Sig.s.fit <- vector('list', length = reps)
for(t in 1:reps){
s2.fit[t] <- summary(Y.geo.fit[[t]])$spatial.component[1]
phi.fit[t] <- summary(Y.geo.fit[[t]])$spatial.component[2]
Sig.s.fit[[t]] <- s2.fit[t] * exp( - D / phi.fit[[t]])
}
phi.fit
s2.fit
Y.geo.fit
str(Y.geo.fit)
Y.list[[1]]
Y.list[[2]]
make.krige.fit <- function(reps, Y.list, H.list, locs){
Y.geo <- as.geodata(cbind(Y.list[[reps]], locs[H.list[[reps]]], rep(0, length(H.list[[reps]]))),
coords.col = 2:3, data.col = 1)
Y.geo.var <- variog(Y.geo, ini.cov.pairs = c(1, 2), trend = '1st', max.dist = 0.75,
messages = FALSE)
variofit(Y.geo.var, messages = FALSE, cov.model = 'exponential',
weights = 'cressie', fix.nugget = TRUE, nugget = 0, fix.kappa = TRUE, kappa = 0)
}
Y.geo.fit <- lapply(1:reps, make.krige.fit, Y.list = Y.list, H.list = H.list, locs = locs)
s2.fit <- vector(length = reps)
phi.fit <- vector(length = reps)
Sig.s.fit <- vector('list', length = reps)
for(t in 1:reps){
s2.fit[t] <- summary(Y.geo.fit[[t]])$spatial.component[1]
phi.fit[t] <- summary(Y.geo.fit[[t]])$spatial.component[2]
Sig.s.fit[[t]] <- s2.fit[t] * exp( - D / phi.fit[t])
}
s2.fit
phi.fit
str(Sig.s.fit)
Sig.s
str(Sig.s)
Sig.s=Sig.s.fit
make.pred <- function(reps, Y.list, H.list, mu, Sig){
pred <- vector(length = m)
pred[ - H.list[[reps]]] <- mu[ - H.list[[reps]]] + Sig.s[[reps]][ - H.list[[reps]], H.list[[reps]]] %*%
solve(Sig.s[[reps]][H.list[[reps]], H.list[[reps]]]) %*% (Y.list[[reps]] - mu[H.list[[reps]]])
pred[H.list[[reps]]] <- Y.list[[reps]]
return(pred)
}
pred[ - H.list[[reps]]] <- mu[ - H.list[[reps]]] + Sig.s[[reps]][ - H.list[[reps]], H.list[[reps]]] %*%
solve(Sig.s[[reps]][H.list[[reps]], H.list[[reps]]]) %*% (Y.list[[reps]] - mu[H.list[[reps]]])
pred
pred[H.list[[reps]]] <- Y.list[[reps]]
return(pred)
pred
plot(pred, type = 'l')
dim(Sig.s)
length(Sig.s)
dim(Sig.s[[1]])
Sig.s[[reps]]
Sig.s[[reps]][ - H.list[[reps]], H.list[[reps]]]
str(Sig.s[[reps]][ - H.list[[reps]], H.list[[reps]]])
Sig.s[[reps]][H.list[[reps]], H.list[[reps]]]
str(Sig.s[[reps]][H.list[[reps]], H.list[[reps]]])
head(Sig.s[[reps]])
(Y.list[[reps]] - mu[H.list[[reps]]]
)
mu[ - H.list[[reps]]]
pred[ - H.list[[reps]]] <- mu[ - H.list[[reps]]] + Sig.s[[reps]][ - H.list[[reps]], H.list[[reps]]] %*%
solve(Sig.s[[reps]][H.list[[reps]], H.list[[reps]]]) %*% (Y.list[[reps]] - mu[H.list[[reps]]])
pred
reps
Y.list[[reps]]
Sig=Sig.s.fit
str(Sig)
Z.pred <- lapply(1:reps, make.pred, Y.list = Y.list, H.list = H.list, mu = mu, Sig = Sig.s.fit)
Sig[[reps]][H.list[[reps]], H.list[[reps]]]
mu[ - H.list[[reps]]]
str(mu[ - H.list[[reps]]])
Sig[[reps]][ - H.list[[reps]], H.list[[reps]]] %*%
solve(Sig[[reps]][H.list[[reps]], H.list[[reps]]]) %*% (Y.list[[reps]] - mu[H.list[[reps]]])
str(Sig[[reps]][ - H.list[[reps]], H.list[[reps]]] %*%
solve(Sig[[reps]][H.list[[reps]], H.list[[reps]]]) %*% (Y.list[[reps]] - mu[H.list[[reps]]]))
str(apply(1:reps, Z, mean)
)
?apply
str(apply(Z, 1, mean)
)
str(apply(Z, 2, mean))
?lapply
mu.hat <- lapply(Y.list, mean)
mu.hat
Y.geo.fit <- lapply(1:reps, make.krige.fit, Y.list = Y.list, H.list = H.list, locs = locs)
s2.fit <- vector(length = reps)
phi.fit <- vector(length = reps)
Sig.s.fit <- vector('list', length = reps)
for(t in 1:reps){
s2.fit[t] <- summary(Y.geo.fit[[t]])$spatial.component[1]
phi.fit[t] <- summary(Y.geo.fit[[t]])$spatial.component[2]
Sig.s.fit[[t]] <- s2.fit[t] * exp( - D / phi.fit[t])
}
## Predict spatial field Using Kriging with estimated covariance
Z.pred <- lapply(1:reps, make.pred)
mu.hat <- lapply(Y.list, mean)
make.pred <- function(reps, Y.list, H.list, mu, Sig){
pred <- vector(length = m)
pred[ - H.list[[reps]]] <- mu[ - H.list[[reps]]] + Sig[[reps]][ - H.list[[reps]], H.list[[reps]]] %*%
solve(Sig[[reps]][H.list[[reps]], H.list[[reps]]]) %*% (Y.list[[reps]] - mu[H.list[[reps]]])
pred[H.list[[reps]]] <- Y.list[[reps]]
return(pred)
}
Z.pred <- lapply(1:reps, make.pred, Y.list = Y.list, H.list = H.list, mu = mu, Sig = Sig.s.fit)
for(t in 1:reps){
Z.pred <- vector(length = m)
Z.pred[ - H.list] <- mu[ - H.list] + Sig.s[ - H.list, H.list] %*%
solve(Sig.s[H.list, H.list]) %*% (Y.list - mu[H.list])
Z.pred[H.list] <- Y.list
## predice spatial field using estimated mean and covariance
}
rm(list = ls())
##
## Libraries and Subroutines
##
library(geoR)
#library(gstat)
library(mvtnorm)
library(gplots)
set.seed(101)
make.field <- function(reps, mu, Sig.s, m){
mu + t(chol(Sig.s)) %*% rnorm(m)
}
make.Y.list <- function(reps, Z, H.list, s2.e = 1){
Z[, reps][H.list[[reps]]] + rnorm(length(H.list[[reps]]), s2.e)
}
make.H.list <- function(reps, samp, m){
(1:m)[samp[[reps]]]
}
make.krige.fit <- function(reps, Y.list, H.list, locs){
Y.geo <- as.geodata(cbind(Y.list[[reps]], locs[H.list[[reps]]], rep(0, length(H.list[[reps]]))),
coords.col = 2:3, data.col = 1)
Y.geo.var <- variog(Y.geo, ini.cov.pairs = c(1, 2), trend = '1st', max.dist = 0.75,
messages = FALSE)
variofit(Y.geo.var, messages = FALSE, cov.model = 'exponential',
weights = 'cressie', fix.nugget = TRUE, nugget = 0, fix.kappa = TRUE, kappa = 0)
}
####
####  Simulate 1-D spatial random fields with trend
####
m <- 1000 # number of spatial locations
locs <- seq(0, 1, , m) # spatial coordinate
reps <- 100 # number of spatial fields
X <- cbind(rep(1, m), locs)
beta <- c(0, 2) # beta
mu <- X %*% beta # mean function
##
## Exponentail Spatial Decay Function s2.s * exp( - D / phi)
##
s2.s <- 1 # spatial variance parameter
phi <- .25 # spatial decay for exponential
D <- as.matrix(dist(locs)) # distance matrix
Sig.s <- s2.s * exp( - D / phi) # spatial covariance matrix
Sig.s.inv <- solve(Sig.s)
##
## Simulate Random Field without nugget
##
Z <- sapply(1:reps, make.field, mu = mu, Sig.s = Sig.s, m = m)
##
## Image full data
##
matplot(Z, type = "l", lty = 1, main = "1-D Spatial Field")
## Krige the full data
## Assume stationarity and anisotropy
Z.geo <- list(length = reps)
Z.geo.var <- list(length = reps)
Z.geo.fit <- list(length = reps)
for(t in 1:reps){
Z.geo[[t]] <- as.geodata(cbind(Z[, t], locs, rep(0, m)), coords.col = 2:3, data.col = 1)
Z.geo.var[[t]] <- variog(Z.geo[[t]], ini.cov.pairs = c(1, 2), trend = '1st',
max.dist = 0.75, messages = FALSE)
Z.geo.fit[[t]] <- variofit(Z.geo.var[[t]], messages = FALSE, cov.model = 'exponential',
weights = 'cressie', fix.nugget = TRUE, nugget = 0, fix.kappa = TRUE, kappa = 0)
}
matplot(Z, type = "l", lty = 1, main = "1-D Spatial Field")
## Krige the full data
## Assume stationarity and anisotropy
Z.geo <- list(length = reps)
Z.geo.var <- list(length = reps)
Z.geo.fit <- list(length = reps)
for(t in 1:reps){
Z.geo[[t]] <- as.geodata(cbind(Z[, t], locs, rep(0, m)), coords.col = 2:3, data.col = 1)
Z.geo.var[[t]] <- variog(Z.geo[[t]], ini.cov.pairs = c(1, 2), trend = '1st',
max.dist = 0.75, messages = FALSE)
Z.geo.fit[[t]] <- variofit(Z.geo.var[[t]], messages = FALSE, cov.model = 'exponential',
weights = 'cressie', fix.nugget = TRUE, nugget = 0, fix.kappa = TRUE, kappa = 0)
}
## Plot Semivariogram
plot(Z.geo.var[[t]])
lines(Z.geo.fit[[t]])
s2.fit <- vector('list', length = reps)
phi.fit <- vector('list', length = reps)
Sig.s.fit <- vector('list', length = reps)
for(t in 1:reps){
s2.fit[[t]] <- summary(Z.geo.fit[[t]])$spatial.component[1]
phi.fit[[t]] <- summary(Z.geo.fit[[t]])$spatial.component[2]
Sig.s.fit[[t]] <- s2.fit[[t]] * exp( - D / phi.fit[[t]])
}
s2.e <- 0.1 # sampling error
samp.size <- sample(40:100, reps, replace = TRUE) # sample size
samp <- vector('list', length = reps)
for(t in 1:reps){
samp[[t]] <- sample(1:m, samp.size[[t]])
}
H.list <- lapply(1:reps, make.H.list, samp = samp, m = m)
Y.list <- lapply(1:reps, make.Y.list, Z = Z, H.list = H.list, s2.e = s2.e)
#save.image(file = "1dKrige.RData")
##
## Krige the data
##
##  coords.col = 2:3, data.col = 1)
Y.geo.fit <- lapply(1:reps, make.krige.fit, Y.list = Y.list, H.list = H.list, locs = locs)
s2.fit <- vector(length = reps)
phi.fit <- vector(length = reps)
Sig.s.fit <- vector('list', length = reps)
for(t in 1:reps){
s2.fit[t] <- summary(Y.geo.fit[[t]])$spatial.component[1]
phi.fit[t] <- summary(Y.geo.fit[[t]])$spatial.component[2]
Sig.s.fit[[t]] <- s2.fit[t] * exp( - D / phi.fit[t])
}
## Predict spatial field Using Kriging with estimated covariance
Z.pred <- lapply(1:reps, make.pred)
make.pred <- function(reps, Y.list, H.list, mu, Sig){
pred <- vector(length = m)
pred[ - H.list[[reps]]] <- mu[ - H.list[[reps]]] + Sig[[reps]][ - H.list[[reps]], H.list[[reps]]] %*%
solve(Sig[[reps]][H.list[[reps]], H.list[[reps]]]) %*% (Y.list[[reps]] - mu[H.list[[reps]]])
pred[H.list[[reps]]] <- Y.list[[reps]]
return(pred)
}
mu.hat <- lapply(Y.list, mean)
Z.pred <- lapply(1:reps, make.pred, Y.list = Y.list, H.list = H.list, mu = mu, Sig = Sig.s.fit)
reps
Y.geo.fit <- lapply(1:reps, make.krige.fit, Y.list = Y.list, H.list = H.list, locs = locs)
s2.fit <- vector(length = reps)
phi.fit <- vector(length = reps)
Sig.s.fit <- vector('list', length = reps)
Y.geo.fit <- lapply(1:reps, make.krige.fit, Y.list = Y.list, H.list = H.list, locs = locs)
for(t in 1:reps){
s2.fit[t] <- summary(Y.geo.fit[[t]])$spatial.component[1]
phi.fit[t] <- summary(Y.geo.fit[[t]])$spatial.component[2]
Sig.s.fit[[t]] <- s2.fit[t] * exp( - D / phi.fit[t])
}
Sig.s.fit[[1]]
Sig.s.fit[[1]][1:10,1:10]
Sig.s.fit[[10]][1:10,1:10]
Sig.s.fit[[110]][1:10,1:10]
Sig.s.fit[[100]][1:10,1:10]
D
for(t in 1:reps){
s2.fit[t] <- summary(Y.geo.fit[[t]])$spatial.component[1]
phi.fit[t] <- summary(Y.geo.fit[[t]])$spatial.component[2]
Sig.s.fit[[t]] <- s2.fit[t] * exp( - D / phi.fit[t])
}
Sig.s.fit[[1]][1:10, 1:10]
phi.fit
phi.fit[[1]]
Y.geo.fit[[1]]
Y.geo.fit[[2]]
Sig.s <- s2.s * exp( - D / phi) # spatial covariance matrix
Sig.s.inv <- solve(Sig.s)
Sig.s
for(t in 1:reps){
s2.fit[t] <- summary(Z.geo.fit[t])$spatial.component[1]
phi.fit[t] <- summary(Z.geo.fit[t])$spatial.component[2]
Sig.s.fit[[t]] <- s2.fit[t] * exp( - D / phi.fit[t])
}
s2.fit[t] <- summary(Z.geo.fit[[t]])$spatial.component[1]
for(t in 1:reps){
s2.fit[t] <- summary(Z.geo.fit[[t]])$spatial.component[1]
phi.fit[t] <- summary(Z.geo.fit[[t])$spatial.component[2]
Sig.s.fit[[t]] <- s2.fit[t] * exp( - D / phi.fit[t])
}
for(t in 1:reps){
s2.fit[t] <- summary(Z.geo.fit[[t]])$spatial.component[1]
phi.fit[t] <- summary(Z.geo.fit[[t]])$spatial.component[2]
Sig.s.fit[[t]] <- s2.fit[t] * exp( - D / phi.fit[t])
}
make.krige.fit <- function(reps, Y.list, H.list, locs){
Y.geo <- as.geodata(cbind(Y.list[[reps]], locs[H.list[[reps]]],
rep(0, length(H.list[[reps]]))), coords.col = 2:3, data.col = 1)
Y.geo.var <- variog(Y.geo, ini.cov.pairs = c(1, 2), trend = '1st',
max.dist = 0.75, messages = FALSE)
variofit(Y.geo.var, messages = FALSE, cov.model = 'exponential',
weights = 'cressie', fix.nugget = TRUE, nugget = 0, fix.kappa = TRUE, kappa = 0)
}
make.krige.fit <- function(reps, Y.list, H.list, locs){
Y.geo <- as.geodata(cbind(Y.list[[reps]], locs[H.list[[reps]]],
rep(0, length(H.list[[reps]]))), coords.col = 2:3, data.col = 1)
Y.geo.var <- variog(Y.geo, ini.cov.pairs = c(1, 2), trend = '1st',
max.dist = 0.75, messages = FALSE)
variofit(Y.geo.var, messages = FALSE, cov.model = 'exponential',
weights = 'cressie', fix.nugget = TRUE, nugget = 0, fix.kappa = TRUE, kappa = 0)
}
Y.geo.fit <- lapply(1:reps, make.krige.fit, Y.list = Y.list, H.list = H.list, locs = locs)
length(Y.geo.fit)
s2.fit <- vector(length = reps)
phi.fit <- vector(length = reps)
Sig.s.fit <- vector('list', length = reps)
for(t in 1:reps){
s2.fit[t] <- summary(Y.geo.fit[[t]])$spatial.component[1]
phi.fit[t] <- summary(Y.geo.fit[[t]])$spatial.component[2]
Sig.s.fit[[t]] <- s2.fit[t] * exp( - D / phi.fit[t])
}
phi.fit
s2.fit
?variofit
make.krige.fit <- function(reps, Y.list, H.list, locs){
Y.geo <- as.geodata(cbind(Y.list[[reps]], locs[H.list[[reps]]],
rep(0, length(H.list[[reps]]))), coords.col = 2:3, data.col = 1)
Y.geo.var <- variog(Y.geo, ini.cov.pairs = c(1, 2), trend = '1st',
max.dist = 0.75, messages = FALSE)
Y.geo.fit <- variofit(Y.geo.var, messages = FALSE, cov.model = 'exponential',
weights = 'cressie', fix.nugget = TRUE, nugget = 0, fix.kappa = TRUE, kappa = 0)
return(Y.geo.fit)
}
Y.geo.fit <- lapply(1:reps, make.krige.fit, Y.list = Y.list, H.list = H.list, locs = locs)
s2.fit <- vector(length = reps)
phi.fit <- vector(length = reps)
Sig.s.fit <- vector('list', length = reps)
for(t in 1:reps){
s2.fit[t] <- summary(Y.geo.fit[[t]])$spatial.component[1]
phi.fit[t] <- summary(Y.geo.fit[[t]])$spatial.component[2]
Sig.s.fit[[t]] <- s2.fit[t] * exp( - D / phi.fit[t])
}
phi.fit
make.pred
Z.pred <- lapply(1:reps, make.pred, Y.list = Y.list, H.list = H.list, mu = mu, Sig = Sigma.s)
Z.pred <- lapply(1:reps, make.pred, Y.list = Y.list, H.list = H.list, mu = mu, Sig = Sig.s)
for(t in 1:reps){
Sig[[t]] <- Sig.s
}
Sig <- vector('list', length = reps)
for(t in 1:reps){
Sig[[t]] <- Sig.s
}
Z.pred <- lapply(1:reps, make.pred, Y.list = Y.list, H.list = H.list, mu = mu, Sig = Sig)
matplot(Z.pred)
matplot(Z.pred, type = 'l')
str(Z.pred)
unlist(Z.pred)
matrix(unlist(Z.pred), nrow = 1000)
dim(matrix(unlist(Z.pred), nrow = 1000))
matplot(matrix(unlist(Z.pred), nrow = 1000))
matplot(matrix(unlist(Z.pred), nrow = 1000), type = 'l')
matplot(matrix(unlist(Z.pred), ncol = 1000), type = 'l')
Z.pred <- matrix(unlist(Z.pred), nrow = m)
matplot(Z.pred, type = 'l')
Y.geo.fit <- lapply(1:reps, make.krige.fit, Y.list = Y.list, H.list = H.list, locs = locs)
matplot(Z.pred, type = 'l', lty = 1, main = "Predicted 1-D Spatial Field")
matplot(Z, type = "l", lty = 2, col = 2, main = "1-D Spatial Field", add = TRUE)
smartlegend("left", "top", cex = (0.5), c("Predicted", "True"), col = c(1, 2), lty = c(1, 2))
?par
matplot(Z.pred, type = 'l', lty = 1, main = "Predicted 1-D Spatial Field")
matplot(Z, type = "l", lty = 2, col = 2, main = "1-D Spatial Field", add = TRUE)
matplot(Z, type = "l", lty = 2, col = 2, main = "1-D Spatial Field")
matplot(Z, type = "l", lty = 2, main = "1-D Spatial Field")
matplot(Z, type = "l", lty = 1, main = "1-D Spatial Field")
layout(matrix(1:2, 2))matplot(Z.pred, type = 'l', lty = 1, main = "Predicted 1-D Spatial Field")
layout(matrix(1:2, 2))
matplot(Z.pred, type = 'l', lty = 1, main = "Predicted 1-D Spatial Field")
matplot(Z, type = "l", lty = 1, main = "1-D Spatial Field")
layout(matrix(1:2, 2))
matplot(Z.pred, type = 'l', lty = 1, main = "Predicted 1-D Spatial Field")
matplot(Z, type = "l", lty = 1, main = "1-D Spatial Field")
layout(matrix(1:2, 2))
matplot(Z.pred, type = 'l', lty = 1, main = "Predicted 1-D Spatial Field")
matplot(Z, type = "l", lty = 1, main = "1-D Spatial Field")
matplot(Z, type = "l", lty = 1, main = "1-D Spatial Field")
layout(matrix(1:2, 2))
matplot(Z.pred, type = 'l', lty = 1, main = "Predicted 1-D Spatial Field")
matplot(Z, type = "l", lty = 1, main = "1-D Spatial Field")
layout(matrix(1:2, 2))
matplot(Z.pred, type = 'l', lty = 1, main = "Predicted 1-D Spatial Field")
matplot(Z, type = "l", lty = 1, main = "1-D Spatial Field")
rm(list = ls())
##
## Libraries and Subroutines
##
library(geoR)
#library(gstat)
library(mvtnorm)
library(gplots)
set.seed(101)
make.field <- function(reps, mu, Sig.s, m){
mu + t(chol(Sig.s)) %*% rnorm(m)
}
make.Y.list <- function(reps, Z, H.list, s2.e = 1){
Z[, reps][H.list[[reps]]] + rnorm(length(H.list[[reps]]), s2.e)
}
make.H.list <- function(reps, samp, m){
(1:m)[samp[[reps]]]
}
make.krige.fit <- function(reps, Y.list, H.list, locs){
Y.geo <- as.geodata(cbind(Y.list[[reps]], locs[H.list[[reps]]],
rep(0, length(H.list[[reps]]))), coords.col = 2:3, data.col = 1)
Y.geo.var <- variog(Y.geo, ini.cov.pairs = c(1, 2), trend = '1st',
max.dist = 0.75, messages = FALSE)
Y.geo.fit <- variofit(Y.geo.var, messages = FALSE, cov.model = 'exponential',
weights = 'cressie', fix.nugget = TRUE, nugget = 0, fix.kappa = TRUE, kappa = 0)
return(Y.geo.fit)
}
make.pred <- function(reps, Y.list, H.list, mu, Sig){
pred <- vector(length = m)
pred[ - H.list[[reps]]] <- mu[ - H.list[[reps]]] + Sig[[reps]][ - H.list[[reps]], H.list[[reps]]] %*%
solve(Sig[[reps]][H.list[[reps]], H.list[[reps]]]) %*% (Y.list[[reps]] - mu[H.list[[reps]]])
pred[H.list[[reps]]] <- Y.list[[reps]]
return(pred)
}
####
####  Simulate 1-D spatial random fields with trend
####
m <- 1000 # number of spatial locations
locs <- seq(0, 1, , m) # spatial coordinate
reps <- 100 # number of spatial fields
X <- cbind(rep(1, m), locs)
beta <- c(0, 2) # beta
mu <- X %*% beta # mean function
##
## Exponentail Spatial Decay Function s2.s * exp( - D / phi)
##
s2.s <- 1 # spatial variance parameter
phi <- .25 # spatial decay for exponential
D <- as.matrix(dist(locs)) # distance matrix
Sig.s <- s2.s * exp( - D / phi) # spatial covariance matrix
Sig.s.inv <- solve(Sig.s)
##
## Simulate Random Field without nugget
##
Z <- sapply(1:reps, make.field, mu = mu, Sig.s = Sig.s, m = m)
##
##
matplot(Z, type = "l", lty = 1, main = "1-D Spatial Field")
## Image full data
## Krige the full data
## Assume stationarity and anisotropy
Z.geo <- list(length = reps)
Z.geo.var <- list(length = reps)
Z.geo.fit <- list(length = reps)
for(t in 1:reps){
Z.geo[[t]] <- as.geodata(cbind(Z[, t], locs, rep(0, m)), coords.col = 2:3, data.col = 1)
Z.geo.var[[t]] <- variog(Z.geo[[t]], ini.cov.pairs = c(1, 2), trend = '1st',
max.dist = 0.75, messages = FALSE)
Z.geo.fit[[t]] <- variofit(Z.geo.var[[t]], messages = FALSE, cov.model = 'exponential',
weights = 'cressie', fix.nugget = TRUE, nugget = 0, fix.kappa = TRUE, kappa = 0)
}
