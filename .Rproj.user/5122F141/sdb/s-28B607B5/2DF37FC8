{
    "contents" : "##\n## MCMC pallette algorithm\n##\n## John Tipton\n##\n## Created 11.12.2013\n##\n\n##\n\n## Model: y_t = K_t %*% X %*% B_t + espilon_t\n##\n##        B_t ~ N(mu_B, Sigma_B) \n##\n##        mu_B ~ N(mu_0, Sigma_0)  \n##\n## X_t = f(Y_tau) where the Y's are the simulated curves for years tau where the simulated data exits and f() is a PCA transformation\n##\n## y_t are the sampled observations for year t\n##\n## K_t is the selection matrix that ties observation locations for the sampled data to the simulated data\n##\n## Sigma_B is the matrix of eigenvalues or eigenvectors? for shrinkage. Something like: sigma^2_B * Lambda^(-1) for the eigenvector(value) matrix Lambda\n##\n## mu_0 and Sigma_0 are hyperparameters\n##\n\nmcmc.1d <- function(Y.list, H.list, locs, n.mcmc, mu.0, Sigma.0, sigma.squared.beta, sigma.squared.eta, alpha.epsilon, beta.epsilon, alpha.beta, beta.beta, alpha.phi, beta.phi, mu.beta,  s.star, sigma.squared.eta.tune, sigma.squared.epsilon.tune, phi.tune){\n\n## params = c(mu.0, Sigma.0, alpha.beta, beta.beta, alpha.eta, beta.eta, alpha.epsilon, beta.epsilon, alpha.phi, beta.phi, n.mcmc = 5000)\n  ##\n  ## Libraries and Subroutines\n  ##\n\n\tdinvgamma = function(x, shape = 1, rate = 1, scale = 1/rate, log = FALSE) {\n\t\t# return( rate^shape / gamma(shape) * exp( - rate / x) * x^( - shape - 1))\n\t\tlogval = shape * log(rate) - lgamma(shape) - rate / x - (shape + 1) * log(x)\n\t\tif (log)\n\t\t\treturn(logval)\n\t\telse\n\t\t\treturn(exp(logval))\n\t}\n\t\n  make.vector <- function(s, beta, Sigma.inv){\n    t(y[[s]] - H[[s]] %*% X %*% beta[, s]) %*% (Sigma.inv[[s]]) %*% (y[[s]] - H[[s]] %*% X %*% beta[, s])\n  }\n\n  make.sum.sigma.beta <- function(beta, mu.beta){\n    temp <- vector(length = t)\n    for(s in 1:t){\n    \t  temp[s] <- t(beta[, s] - mu.beta) %*% Lambda.inv %*% (beta[, s] - mu.beta)\n    }\n    return(sum(temp))\n  }\n\n  make.Sigma <- function(s, Sigma.epsilon, C.star, c){\n    H[[s]] %*% Sigma.beta + Sigma.eta\n\n %*% t(H[[s]]) + Sigma.epsilon[[s]]\n  }\n\n  make.Sigma.inv <- function(s, Sigma.epsilon.inv, C.star.inv, c){\n    Sigma.epsilon.inv[[s]] - Sigma.epsilon.inv[[s]] %*% H[[s]] %*% t(c) %*% solve(C.star.inv + c %*% t(H[[s]]) %*% Sigma.epsilon.inv[[s]] %*% H[[s]] %*% t(c)) %*% c %*% t(H[[s]]) %*% Sigma.epsilon.inv[[s]]\n  }\n\n##\n## Predictive Process\n##\n\n##  make.mh <- function(s, beta, Sigma.epsilon, Sigma.epsilon.inv, Sigma.inv, C.star, C.star.inv, c){\n##    ( - t / 2) * (determinant(C.star.inv + c %*% t(H[[s]]) %*% Sigma.epsilon.inv[[s]] %*% H[[s]] %*% t(c), logarithm = TRUE)$modulus[1] + \n##      determinant(C.star, logarithm = TRUE)$modulus[1] + determinant(Sigma.epsilon[[s]], logarithm = TRUE)$modulus[1]) - \n ##     1 / 2 * t(y[[s]] - H[[s]] %*% X %*% beta[, s]) %*% (Sigma.inv[[s]]) %*% (y[[s]] - H[[s]] %*% X %*% beta[, s])\n##  }\n\n##  make.c <- function(sigma.squared.eta, phi){\n##    sigma.squared.eta * exp( - D.0 / phi)\n##  }\n  \n##  make.C.star <- function(sigma.squared.eta, phi){\n##  \tsigma.squared.eta * exp( - D.star / phi)\n##  }\n  \n##  make.C.star.inv <- function(C.star){\n##    solve(C.star)\n##  }\n\n##  make.Sigma <- function(s, Sigma.epsilon, C.star, c){\n##  \tH[[s]] %*% t(c) %*% C.star %*% c %*% t(H[[s]]) + Sigma.epsilon[[s]]\n##  }\n\n##  make.Sigma.inv <- function(s, Sigma.epsilon.inv, C.star.inv, c){\n ## \tSigma.epsilon.inv[[s]] - Sigma.epsilon.inv[[s]] %*% H[[s]] %*% t(c) %*% solve(C.star.inv + c %*% t(H[[s]]) %*% Sigma.epsilon.inv[[s]] %*% H[[s]] %*% t(c)) %*% c %*% t(H[[s]]) %*% Sigma.epsilon.inv[[s]]\n ## }\n  \n ## make.Sigma.epsilon <- function(s, sigma.squared.epsilon){\n ##   Sigma.epsilon[[s]] <- sigma.squared.epsilon * diag(nt[s])\n ## }\n  \n##  make.Sigma.epsilon.inv <- function(s, Sigma.epsilon){\n##    solve(Sigma.epsilon[[s]])\n##  }\n  \n##  make.fort.batch <- function(s, beta, c, C.star, C.star.inv, sigma.squared.epsilon){#, w.tilde){\n##  \tw.star <- rmvnorm(1, vec.0, C.star)\n##    w.tilde <- t(c) %*% C.star.inv %*% t(w.star)\n  \tif(dim(beta)[1] == 1){\n  \t\tX * beta[s] + w.tilde + rnorm(ncells, 0, sigma.squared.epsilon)\n  \t} else {\n  \t\tX %*% beta[, s] + w.tilde + rnorm(ncells, 0, sigma.squared.epsilon)\n  \t}\n  }\n\n  ##\n  ## Initialize parameters\n  ## \n  \n  t <- length(y)\n  if(is.null(dim(X)) == TRUE){ncells <- length(X)} else {ncells <- dim(X)[1]}\n  if(is.null(dim(X)) == TRUE){tau <- 1} else {tau <- dim(X)[2]}\n  nt <- c()\n  for(s in 1:t){\n  \tnt[s] <- length(y[[s]])\n  }\n  nt.sum <- sum(nt)\n##  n.knots <- length(s.star) # predictive process\n  ## Initialze process\n  beta <- matrix(0, nrow = tau, ncol = t)\n  ## Initialize parameter model\n  devs <- rnorm(t)\n  Sigma.chol <- chol(Sigma.0)\n  mu.beta <- backsolve(Sigma.chol, backsolve(Sigma.0, mu.0, transpose = TRUE) + devs)\n\n  sigma.squared.beta <- 1 / rgamma(1, alpha.beta, beta.beta)\n  Sigma.beta <- sigma.squared.beta\n  Sigma.beta.inv <- solve(Sigma.beta)\n\n  sigma.squared.eta <- 1 / rgamma(1, alpha.eta, beta.eta)\n\n  sigma.squared.epsilon <- 1 / rgamma(1, alpha.epsilon, beta.epsilon)\n  Sigma.epsilon <- vector('list', length = t)\n  Sigma.epsilon.inv <- vector('list', length = t)\n  Sigma.epsilon <- lapply(1:t, make.Sigma.epsilon, sigma.squared.epsilon = sigma.squared.epsilon)\n  Sigma.epsilon.inv <- lapply(1:t, make.Sigma.epsilon.inv, Sigma.epsilon = Sigma.epsilon)\n\n  phi <- 1 / rgamma(1, alpha.phi, beta.phi)\n\n  Sigma.0.inv <- solve(Sigma.0)\n\n\n  n.burn <- floor(n.mcmc / 10)\n  fort.raster.batch <- matrix(0, ncells, t)   \n\n##  Distance Matrices for Predictive Process\n##  D.star <- as.matrix(dist(s.star))\n##  D.0 <- matrix(nrow = n.knots, ncol = ncells)\n##    for(i in 1:n.knots){\n##    for(j in 1:ncells){\n##  \t  D.0[i, j] <- sqrt((s.star[i] - locs[j])^2)\n##  }\n##  }\n##  vec.0 <- rep(0, n.knots)\n##  C.star <- make.C.star(sigma.squared.eta = sigma.squared.eta, phi = phi)\n##  w.star <- rmvnorm(1, vec.0, C.star)\n##  C.star.inv <- make.C.star.inv(C.star)\n##  c <- \tmake.c(sigma.squared.eta, phi)\n##  Sigma <- vector('list', length = t)\n##  Sigma.inv <- vector('list', length = t)\n##  Sigma <- lapply(1:t, make.Sigma, Sigma.epsilon = Sigma.epsilon, C.star = C.star, c = c) \n##  Sigma.inv <- lapply(1:t, make.Sigma.inv, Sigma.epsilon.inv = Sigma.epsilon.inv, C.star.inv = C.star.inv, c = c)\n  tHX <- vector('list', length = t)\n  HX <- vector('list', length = t)\n  for(s in 1:t){\n  \tHX[[s]] <- H[[s]] %*% X  \n  \ttHX[[s]] <- t(HX[[s]])\n  }\n  \n  ##\n  ## Initialize Storage\n  ##\n  \n  beta.save <- array(dim = c(tau, t, n.mcmc))\n  sigma.squared.beta.save <- vector(length = n.mcmc)\n  sigma.squared.epsilon.save <- vector(length = n.mcmc)\n  sigma.squared.eta.save <- vector(length = n.mcmc)\n  mu.beta.save <- matrix(NA, nrow = tau, ncol = n.mcmc)\n  fort.raster <- matrix(0, nrow = ncells, ncol = t)\n  MSPE.save <- 0\n  var.save <- matrix(0, nrow = ncells, ncol = t)\n  var.save.temp <- array(dim = c(100, ncells, t))\n  phi.accept <- 0  \n  eta.accept <- 0\n  epsilon.accept <- 0\n  phi.save <- vector(length = n.mcmc)\n\n  ##\n  ## Begin MCMC loop\n  ##\n\n\tfor(k in 1:n.mcmc){\n  \tif(k %% 100 == 0) cat(\" \", k)\n\n  \t##\n  \t## Sample Beta\n  \t##\n  \t\n  \tfor(s in 1:t){\n      devs <- rnorm(tau)\n      beta.A.chol <- ## Calculate t(X) %*% H[[s]] once, not in each loop tHX HX\n      if(is.null(dim(H[[s]])) == TRUE){\n        chol(tHX[[s]] %*% Sigma.inv[[s]] %*% HX[[s]] + Sigma.beta.inv)\n      } else {\n        chol(tHX[[s]] %*% Sigma.inv[[s]] %*% HX[[s]] + Sigma.beta.inv)\n      }\n      beta.b <- if(is.null(dim(H[[s]])) == TRUE){\n        tHX[[s]] %*% Sigma.inv[[s]] %*% y[[s]] + Sigma.beta.inv %*% mu.beta\n      } else {\n        tHX[[s]] %*% Sigma.inv[[s]] %*% y[[s]] + Sigma.beta.inv %*% mu.beta\n      }\n      beta[, s] <- backsolve(beta.A.chol, backsolve(beta.A.chol, beta.b, transpose = TRUE) + devs)\n  \t}\n  \t\n  \t##\n  \t## Sample mu.beta\n  \t##\n  \t\n  \tdevs <- rnorm(tau)\n  \tmu.beta.A.chol <- chol(t * Sigma.beta.inv + Sigma.0.inv)\n  \tmu.beta.b <- apply(Sigma.beta.inv %*% beta, 1, sum) + Sigma.0.inv %*% mu.0\n  \tmu.beta <- backsolve(mu.beta.A.chol, backsolve(mu.beta.A.chol, mu.beta.b, transpose = TRUE) + devs)\n  \n  \t##\n  \t## Sample sigma.squared.beta\n  \t##\n  \t\n  \tsigma.squared.beta <- 1 / rgamma(1, alpha.beta + t * Lambda.determinant / 2, 1 / 2 * make.sum.sigma.beta(beta, mu.beta) + beta.beta)  \n  \tSigma.beta <- sigma.squared.beta * Lambda\n  \tSigma.beta.inv <- solve(Sigma.beta)\n  \t\n  \t##\n    ## Sample sigma.squared.eta\n    ##\n  \t\n  \tsigma.squared.eta.star <- rnorm(1, sigma.squared.eta, sigma.squared.eta.tune)\n  \tif(sigma.squared.eta.star > 0){\n      c.star <- make.c(sigma.squared.eta = sigma.squared.eta.star, phi = phi)\n    \tC.star.star <- make.C.star(sigma.squared.eta = sigma.squared.eta.star, phi = phi)\n      C.star.star.inv <- make.C.star.inv(C.star = C.star.star)\n    \tSigma.star <- lapply(1:t, make.Sigma, Sigma.epsilon = Sigma.epsilon, C.star = C.star.star, c = c.star)\n    \tSigma.star.inv <- lapply(1:t, make.Sigma.inv,  Sigma.epsilon = Sigma.epsilon, C.star.inv = C.star.star.inv, c = c.star)\n  \t  mh.eta.1 <-\tsum(sapply(1:t, make.mh, beta = beta, Sigma.epsilon = Sigma.epsilon, Sigma.epsilon.inv = Sigma.epsilon.inv, Sigma.inv = Sigma.star.inv, C.star = C.star.star, C.star.inv = C.star.star.inv, c = c.star)) + dinvgamma(sigma.squared.eta.star, alpha.eta, beta.eta, log = TRUE)\n    \tmh.eta.2 <- sum(sapply(1:t, make.mh, beta = beta, Sigma.epsilon = Sigma.epsilon, Sigma.epsilon.inv = Sigma.epsilon.inv, Sigma.inv = Sigma.inv, C.star = C.star, C.star.inv = C.star.inv, c = c)) + dinvgamma(sigma.squared.eta, alpha.eta, beta.eta, log = TRUE)\n    \tmh.eta <- exp(mh.eta.1 - mh.eta.2)\n  \t  \t\n  \t  if(mh.eta > runif(1)){\n        sigma.squared.eta <- sigma.squared.eta.star\n        c <- c.star\n        C.star <- C.star.star\n        C.star.inv <- C.star.star.inv\n        Sigma <- Sigma.star\n        Sigma.inv <- Sigma.star.inv\n        eta.accept <- eta.accept + 1 / n.mcmc\n      }\n    rm(c.star)\n    rm(C.star.star)\n    rm(C.star.star.inv)\n    rm(Sigma.star)\n    rm(Sigma.star.inv)\n    }\n  rm(sigma.squared.eta.star)\n\n  \t\n  \t##\n  \t## Sample sigma.squared.epsilon\n  \t##\n  \t\n  \tsigma.squared.epsilon.star <- rnorm(1, sigma.squared.epsilon, sigma.squared.epsilon.tune)\n  \tif(sigma.squared.epsilon.star > 0){\n    \tSigma.epsilon.star <- lapply(1:t, make.Sigma.epsilon, sigma.squared.epsilon = sigma.squared.epsilon.star)\n    \tSigma.epsilon.star.inv <- lapply(1:t, make.Sigma.epsilon.inv, Sigma.epsilon = Sigma.epsilon.star)\n    \tSigma.star <- lapply(1:t, make.Sigma, Sigma.epsilon = Sigma.epsilon.star, C.star = C.star, c = c)\n    \tSigma.star.inv <- lapply(1:t, make.Sigma.inv,  Sigma.epsilon = Sigma.epsilon.star, C.star.inv = C.star.inv, c = c)\n  \t  mh.epsilon.1 <-\tsum(sapply(1:t, make.mh, beta = beta, Sigma.epsilon = Sigma.epsilon.star, Sigma.epsilon.inv = Sigma.epsilon.star.inv, Sigma.inv = Sigma.star.inv, C.star = C.star, C.star.inv = C.star.inv, c = c)) + dinvgamma(sigma.squared.epsilon.star, alpha.epsilon, beta.epsilon, log = TRUE)\n    \tmh.epsilon.2 <- sum(sapply(1:t, make.mh, beta = beta, Sigma.epsilon = Sigma.epsilon, Sigma.epsilon.inv = Sigma.epsilon.inv, Sigma.inv = Sigma.inv, C.star = C.star, C.star.inv = C.star.inv, c = c)) + dinvgamma(sigma.squared.epsilon, alpha.epsilon, beta.epsilon, log = TRUE)\n    \tmh.epsilon <- exp(mh.epsilon.1 - mh.epsilon.2)\n  \t\n  \t  if(mh.epsilon > runif(1)){\n    \t\tsigma.squared.epsilon <- sigma.squared.epsilon.star\n    \t\tSigma.epsilon <- Sigma.epsilon.star\n  \t  \tSigma.epsilon.inv <- Sigma.epsilon.star.inv\n  \t\t  Sigma <- Sigma.star\n    \t\tSigma.inv <- Sigma.star.inv\n    \t\tepsilon.accept <- epsilon.accept + 1 / n.mcmc\n  \t  }\n    rm(Sigma.epsilon.star)\n    rm(Sigma.epsilon.star.inv)\n    rm(Sigma.star)\n    rm(Sigma.star.inv)\n  \t}\n  rm(sigma.squared.epsilon.star)\n\n  \t\n  \t##\n  \t## Sample phi\n  \t##\n  \t\n    phi.star <- rnorm(1, phi, phi.tune)\n  \tif(phi.star > 0){\n  \t\tc.star <- make.c(sigma.squared.eta = sigma.squared.eta, phi = phi.star)\n  \t\tC.star.star <- make.C.star(sigma.squared.eta = sigma.squared.eta, phi = phi.star)\n  \t\tC.star.star.inv <- make.C.star.inv(C.star = C.star.star)\n  \t\tSigma.star <- lapply(1:t, make.Sigma, Sigma.epsilon = Sigma.epsilon, C.star = C.star.star, c = c.star)\n  \t\tSigma.star.inv <- lapply(1:t, make.Sigma.inv,  Sigma.epsilon = Sigma.epsilon, C.star.inv = C.star.star.inv, c = c.star)\n  \t\tmh.phi.1 <-\tsum(sapply(1:t, make.mh, beta = beta, Sigma.epsilon = Sigma.epsilon, Sigma.epsilon.inv = Sigma.epsilon.inv, Sigma.inv = Sigma.star.inv, C.star = C.star.star, C.star.inv = C.star.star.inv, c = c.star)) + dinvgamma(phi.star, alpha.phi, beta.phi, log = TRUE)\n  \t\tmh.phi.2 <- sum(sapply(1:t, make.mh, beta = beta, Sigma.epsilon = Sigma.epsilon, Sigma.epsilon.inv = Sigma.epsilon.inv, Sigma.inv = Sigma.inv, C.star = C.star, C.star.inv = C.star.inv, c = c)) + dinvgamma(phi, alpha.phi, beta.phi, log = TRUE)\n  \t\tmh.phi <- exp(mh.phi.1 - mh.phi.2)\n  \t\t  \t\t\n  \t\tif(mh.phi > runif(1)){\n          phi <- phi.star\n          c <- c.star\n          C.star <- C.star.star\n          C.star.inv <- C.star.star.inv\n          Sigma <- Sigma.star\n          Sigma.inv <- Sigma.star.inv\n          phi.accept <- phi.accept + 1 / n.mcmc\n  \t\t}\n    rm(c.star)\n    rm(C.star.star)\n    rm(C.star.star.inv)\n    rm(Sigma.star)\n    rm(Sigma.star.inv)\n    }\n  rm(phi.star)\n\n\n  ##\n  ## Simulate random field\n  ##\n  \n  if(k > n.burn){\n    if(k %% 100 == 0){\n      for(s in 1:t){\n        var.save[, s] <- var.save[, s] + apply(var.save.temp[, , s], 2, var) / ((n.mcmc - n.burn) / 100)\n        fort.raster.batch <- matrix(0, ncells, t)\n      }\n      var.save.temp <- array(0, dim = c(100, ncells, t))\n    }\n    fort.raster <- sapply(1:t, make.fort.batch, beta = beta, c = c, C.star = C.star, C.star.inv = C.star.inv, sigma.squared.epsilon = sigma.squared.epsilon)#, w.tilde = w.tilde)\n    var.save.temp[k %% 100 + 1, , ] <- fort.raster\n  }\n\n#  temp <- c()\n#  for(j in 1:t){\n#    if(is.null(H.list[[j]]) == FALSE){\n#      temp[j] <- (fort.raster[,j][H.list[[j]]] - y.val[,j][loc.id.val[[j]]])^2 \n#    }\n#  }\n#  MSPE.save <- MSPE.save + mean(na.omit(temp)) / (n.mcmc - n.burn)\n  \n  ##\n  ## Save variables\n  ## \n  \n  beta.save[, , k] <- beta\n  sigma.squared.beta.save[k] <- sigma.squared.beta\n  sigma.squared.eta.save[k] <- sigma.squared.eta\n  sigma.squared.epsilon.save[k] <- sigma.squared.epsilon\n  mu.beta.save[, k] <- mu.beta  \n  phi.save[k] <- phi\t\n  }\n  \n##\n## Write output\n##\n  \nlist(beta.save = beta.save, sigma.squared.beta.save = sigma.squared.beta.save, sigma.squared.epsilon.save = sigma.squared.epsilon.save, sigma.squared.eta.save = sigma.squared.eta.save, mu.beta.save = mu.beta.save, n.mcmc = n.mcmc, fort.raster = fort.raster, phi.accept = phi.accept, eta.accept = eta.accept, epsilon.accept = epsilon.accept, phi.save = phi.save, var.save = var.save)#, MSPE.save = MSPE.save)\n}\n\n",
    "created" : 1389302423634.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "2434471432",
    "id" : "2DF37FC8",
    "lastKnownWriteTime" : 1389302204,
    "path" : "~/1dSpatialSim/mcmc.spatial.R",
    "project_path" : "mcmc.spatial.R",
    "properties" : {
    },
    "source_on_save" : false,
    "type" : "r_source"
}