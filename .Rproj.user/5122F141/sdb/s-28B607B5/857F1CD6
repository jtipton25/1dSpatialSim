{
    "contents" : "rm(list = ls())\n\n##\n## Libraries and Subroutines\n##\n\nlibrary(geoR)\n#library(gstat)\nlibrary(mvtnorm)\nlibrary(gplots)\nset.seed(101)\n\n## make true spatial field\nmake.field <- function(reps, mu, Sig.s, m){\n\tmu + t(chol(Sig.s)) %*% rnorm(m)\n}\n\n## make sampling matrix H\nmake.H.list <- function(reps, samp, m){\n  (1:m)[samp[[reps]]]\n}\n\n## make sample data Y\nmake.Y.list <- function(reps, Z, H.list, s2.e = 1){\n  Z[, reps][H.list[[reps]]] + rnorm(length(H.list[[reps]]), s2.e)\n}\n\n\n\nmake.krige.fit <- function(reps, Y.list, H.list, locs){\n  Y.geo <- as.geodata(cbind(Y.list[[reps]], locs[H.list[[reps]]], \n    rep(0, length(H.list[[reps]]))), coords.col = 2:3, data.col = 1)\n  \n  Y.geo.var <- variog(Y.geo, ini.cov.pairs = c(1, 2), trend = '1st', \n    max.dist = 0.75, messages = FALSE)\n  \n  Y.geo.fit <- variofit(Y.geo.var, messages = FALSE, cov.model = 'exponential', \n    weights = 'cressie', fix.nugget = TRUE, nugget = 0, fix.kappa = TRUE, kappa = 0) \n  \n  return(Y.geo.fit)\n}\n\nmake.pred <- function(reps, Y.list, H.list, mu, Sig){\n\tpred <- vector(length = m)\n\tpred[ - H.list[[reps]]] <- mu[ - H.list[[reps]]] + Sig[[reps]][ - H.list[[reps]], H.list[[reps]]] %*% \n\t\tsolve(Sig[[reps]][H.list[[reps]], H.list[[reps]]]) %*% (Y.list[[reps]] - mu[H.list[[reps]]]) \n\tpred[H.list[[reps]]] <- Y.list[[reps]]\n\treturn(pred)\n}\n\nplot.field <- function(Y.list, H.list, locs){\n  reps <- length(Y.list)\n  min.Y <- min(unlist(lapply(Y.list, min)))\n  max.Y <- max(unlist(lapply(Y.list, max)))\n  idx <- order(locs[H.list[[1]]])\n  plot(Y.list[[1]][idx] ~ locs[H.list[[1]]][idx], type = 'l', ylim = c(min.Y, max.Y), main = \"Observed Data\")\n  for(t in 2:reps){\n    idx <- order(locs[H.list[[t]]])\n    lines(Y.list[[t]][idx] ~ locs[H.list[[t]]][idx], type = 'l', col = t)\n  }\n}\n\n####\n####  Simulate 1-D spatial random fields with trend\n####\n\nm <- 1000 # number of spatial locations\nlocs <- seq(0, 1, , m) # spatial coordinate\nreps <- 100 # number of spatial fields\n\nX <- cbind(rep(1, m), locs)\nbeta <- c(0, 2) # beta\nmu <- X %*% beta # mean function\n\n##\n## Exponentail Spatial Decay Function s2.s * exp( - D / phi)\n##\n\ns2.s <- 1 # spatial variance parameter\nphi <- 15 # spatial decay for exponential\nD <- as.matrix(dist(locs)) # distance matrix\nSig.s <- s2.s * exp( - D / phi) # spatial covariance matrix\nSig.s.inv <- solve(Sig.s) \n\n##\n## Simulate Random Field without nugget\n##\n\nZ <- sapply(1:reps, make.field, mu = mu, Sig.s = Sig.s, m = m)\n\n##\n## Image full data\n##\n\nmatplot(Z, type = \"l\", lty = 1, main = \"1-D Spatial Field\")\n\n##\n## Krige the full data\n##\n\n## Assume stationarity and anisotropy\nZ.geo <- list(length = reps)\nZ.geo.var <- list(length = reps)\nZ.geo.fit <- list(length = reps)\n\nfor(t in 1:reps){\n  Z.geo[[t]] <- as.geodata(cbind(Z[, t], locs, rep(0, m)), coords.col = 2:3, data.col = 1)\n  Z.geo.var[[t]] <- variog(Z.geo[[t]], ini.cov.pairs = c(1, 2), trend = '1st', \n    max.dist = 0.75, messages = FALSE)\n  Z.geo.fit[[t]] <- variofit(Z.geo.var[[t]], messages = FALSE, cov.model = 'exponential', \n    weights = 'cressie', fix.nugget = TRUE, nugget = 0, fix.kappa = TRUE, kappa = 0) \n}\n\n## Plot Semivariogram\nfor(t in 1:reps){\n  plot(Z.geo.var[[t]])\n  lines(Z.geo.fit[[t]])\n}\n\ns2.fit <- vector(length = reps)\nphi.fit <- vector(length = reps)\nSig.s.fit <- vector('list', length = reps)\n\t\nfor(t in 1:reps){\n  s2.fit[t] <- summary(Z.geo.fit[[t]])$spatial.component[1]\n  phi.fit[t] <- summary(Z.geo.fit[[t]])$spatial.component[2]\n  Sig.s.fit[[t]] <- s2.fit[t] * exp( - D / phi.fit[t])\n}\n\n####\n####  Subsample Fields and Create Data Matrix   \n####\n\ns2.e <- 0.01 # sampling error\nsamp.size <- sample(140:200, reps, replace = TRUE) # sample size\n\nsamp <- vector('list', length = reps)\nfor(t in 1:reps){\n  samp[[t]] <- sample(1:m, samp.size[[t]])\n}\n\nH.list <- lapply(1:reps, make.H.list, samp = samp, m = m)\nY.list <- lapply(1:reps, make.Y.list, Z = Z, H.list = H.list, s2.e = s2.e)\n\n\n\nplot.field(Y.list = Y.list, H.list = H.list, locs = locs)\n\n#save.image(file = \"1dKrige.RData\")\n\n##\n## Krige the data\n##\n\n##  coords.col = 2:3, data.col = 1)\n\n##\n## Predict spatial field using Kriging with known covariance\n##\n\nSig <- vector('list', length = reps)\n\nfor(t in 1:reps){\n  Sig[[t]] <- Sig.s\n}\n\nZ.pred <- lapply(1:reps, make.pred, Y.list = Y.list, H.list = H.list, mu = mu, Sig = Sig)\nZ.pred <- matrix(unlist(Z.pred), nrow = m)\nmatplot(Z.pred, type = 'l')\n\n##\n## Krige using covariance matrix estimated from sample data\n##\n\n## Has problems due to struggles estimating phi\n\nY.geo.fit <- lapply(1:reps, make.krige.fit, Y.list = Y.list, H.list = H.list, locs = locs)\n\ns2.fit <- vector(length = reps)\nphi.fit <- vector(length = reps)\nSig.s.fit <- vector('list', length = reps)\n\nfor(t in 1:reps){\n\ts2.fit[t] <- summary(Y.geo.fit[[t]])$spatial.component[1]\n\tphi.fit[t] <- summary(Y.geo.fit[[t]])$spatial.component[2]\n\tSig.s.fit[[t]] <- s2.fit[t] * exp( - D / phi.fit[t])\n}\n\n## phi is currently underestimated\n\n## Predict spatial field Using Kriging with estimated covariance\nZ.pred.knownS <- lapply(1:reps, make.pred, Y.list)\nmu.hat <- lapply(Y.list, mean)\n\nZ.pred <- lapply(1:reps, make.pred, Y.list = Y.list, H.list = H.list, mu = mu, Sig = Sig.s.fit)\n  for(t in 1:reps){\nZ.pred <- vector(length = m)\nZ.pred[ - H.list] <- mu[ - H.list] + Sig.s[ - H.list, H.list] %*% \n  solve(Sig.s[H.list, H.list]) %*% (Y.list - mu[H.list]) \nZ.pred[H.list] <- Y.list\n}\n\n## predice spatial field using estimated mean and covariance\n\n##\n## Image full data and predicted surface\n##\n\nlayout(matrix(1:2, 2))\nmatplot(Z.pred.knownS, type = 'l', lty = 1, main = \"Predicted 1-D Spatial Field\")\nmatplot(Z, type = \"l\", lty = 1, main = \"1-D Spatial Field\")\n\n",
    "created" : 1389250670169.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "90711712",
    "id" : "857F1CD6",
    "lastKnownWriteTime" : 1389295134,
    "path" : "~/1dSpatialSim/1dKrige.R",
    "project_path" : "1dKrige.R",
    "properties" : {
        "tempName" : "Untitled1"
    },
    "source_on_save" : false,
    "type" : "r_source"
}