{
    "contents" : "##\n## MCMC spatial kriging algorithm\n##\n## John Tipton\n##\n## Created 01.04.2014\n## Last updated 01.14.2014\n##\n##\n## Model: y_t = H_t %*% X %*% B_t + espilon_t\n##\n##        B_t ~ N(mu_B, Sigma_B) \n##\n##        mu_B ~ N(mu_0, Sigma_0)  \n##\n## X_t = f(Y_tau) where the Y's are the simulated curves for years tau where the simulated data exits and f() is a PCA transformation\n##\n## y_t are the sampled observations for year t\n##\n## H_t is the selection matrix that ties observation locations for the sampled data to the simulated data\n##\n## mu_0 and Sigma_0 are hyperparameters\n##\n\nmcmc.1d <- function(Y.list, H.list, X, locs, n.mcmc, mu.0, Sigma.0, sigma.squared.beta, sigma.squared.eta, alpha.epsilon, beta.epsilon, alpha.beta, beta.beta, alpha.phi, beta.phi, mu.beta, sigma.squared.eta.tune, sigma.squared.epsilon.tune, phi.tune){\n\n## params = c(mu.0, Sigma.0, alpha.beta, beta.beta, alpha.eta, beta.eta, alpha.epsilon, beta.epsilon, alpha.phi, beta.phi, n.mcmc = 5000)\n  \n  ##\n  ## Libraries and Subroutines\n  ##\n\n\tdinvgamma = function(x, shape = 1, rate = 1, scale = 1/rate, log = FALSE) {\n\t\t# return( rate^shape / gamma(shape) * exp( - rate / x) * x^( - shape - 1))\n\t\tlogval = shape * log(rate) - lgamma(shape) - rate / x - (shape + 1) * log(x)\n\t\tif (log)\n\t\t\treturn(logval)\n\t\telse\n\t\t\treturn(exp(logval))\n\t}\n\t\n  make.sum.sigma.beta <- function(beta, mu.beta){\n    temp <- vector(length = t)\n    for(s in 1:t){\n    \t  #temp[s] <- t(beta[, s] - mu.beta) %*% Sigma.beta.inv %*% (beta[, s] - mu.beta)\n      temp[s] <- t(beta[, s] - mu.beta) %*% (beta[, s] - mu.beta)\n    }\n    return(sum(temp))\n  }\n\n  make.D.list <- function(s, H.list, locs){\n    as.matrix(dist(locs[H.list[[s]]]))\n  }\n  \n  make.R.list <- function(s, sigma.squared.eta, phi, D.list){\n    sigma.squared.eta * exp( - D.list[[s]] / phi)\n  }\n  \n  make.identity.list <- function(s, nt){\n    if(length(nt) == 1){\n      diag(nt)\n    } else {\n      diag(nt[s])\n    }\n  }\n  \n  make.Sigma.epsilon <- function(s, sigma.squared.epsilon, I.nt){\n    sigma.squared.epsilon * I.nt[[s]]\n  }\n  \n  make.Sigma.epsilon.inv <- function(s, sigma.squared.epsilon, I.nt){\n    1 / sigma.squared.epsilon * I.nt[[s]]\n  }\n    \n  make.Sigma <- function(s, R.list, Sigma.epsilon){\n    R.list[[s]] + Sigma.epsilon[[s]]\n  }\n  \n  make.Sigma.inv <- function(s, Sigma){\n    solve(Sigma[[s]])\n  }\n  \n\tmake.mh <- function(s, beta, Sigma, Sigma.inv){\n\t  ( - 1 / 2) * determinant(Sigma[[s]], logarithm = TRUE)$modulus[1] - 1 / 2 * t(Y.list[[s]] - HX.list[[s]] %*% beta[, s]) %*% Sigma.inv[[s]] %*% (Y.list[[s]] - HX.list[[s]] %*% beta[, s])\n\t}\n\n\tmake.fort.batch <- function(s, beta, chol.Sigma, ncells){\n\t  if(dim(beta)[1] == 1){  \n\t    backsolve(chol.Sigma, backsolve(chol.Sigma, X * beta[s], transpose = TRUE) + rnorm(ncells))\n\t  } else {\n\t    backsolve(chol.Sigma, backsolve(chol.Sigma, X %*% beta[, s], transpose = TRUE) + rnorm(ncells)) \n\t  }\n\t}\n\n<<<<<<< HEAD\n=======\n\n>>>>>>> 1cdf65f5ac5f5995189ea691d26bbae58da0f0ff\n  ##\n  ## Initialize parameters\n  ## \n  \n  t <- length(Y.list)\n  if(is.null(dim(X)) == TRUE){ncells <- length(X)} else {ncells <- dim(X)[1]}\n  if(is.null(dim(X)) == TRUE){tau <- 1} else {tau <- dim(X)[2]}\n  nt <- c() \n  for(s in 1:t){\n  \tnt[s] <- length(Y.list[[s]])\n  }\n  nt.sum <- sum(nt)\n##  n.knots <- length(s.star) # predictive process\n\n  ## Initialze process\n  beta <- matrix(0, nrow = tau, ncol = t)\n  \n  ## Initialize parameter model\n  sigma.squared.beta <- 1 / rgamma(1, alpha.beta, beta.beta)\n  Sigma.beta <- sigma.squared.beta * diag(tau)\n  Sigma.beta.inv <- solve(Sigma.beta)\n  \n  sigma.squared.eta <- 1 / rgamma(1, alpha.eta, beta.eta)\n  phi <- 1 / rgamma(1, alpha.phi, beta.phi)\n  D <- as.matrix(dist(locs))\n  D.list <- lapply(1:t, make.D.list, H.list = H.list, locs = locs)\n  R.list <- lapply(1:t, make.R.list, sigma.squared.eta = sigma.squared.eta, phi = phi, D.list = D.list)\n    \n  sigma.squared.epsilon <- 1 / rgamma(1, alpha.epsilon, beta.epsilon)\n  I.nt <- lapply(1:t, make.identity.list, nt = nt)\n  Sigma.epsilon <- lapply(1:t, make.Sigma.epsilon, sigma.squared.epsilon = sigma.squared.epsilon, I.nt = I.nt)\n  Sigma.epsilon.inv <- lapply(1:t, make.Sigma.epsilon.inv, sigma.squared.epsilon = sigma.squared.epsilon, I.nt = I.nt)\n\n  Sigma.0 <- sigma.squared.0 * diag(tau)\n  Sigma.0.inv <- solve(Sigma.0)\n\n  Sigma <- lapply(1:t, make.Sigma, R.list = R.list, Sigma.epsilon = Sigma.epsilon)\n  Sigma.inv <- lapply(1:t, make.Sigma.inv, Sigma = Sigma)\n  \n  devs <- rnorm(t)\n\tSigma.chol <- chol(Sigma.0)\n\tmu.beta <- backsolve(Sigma.chol, backsolve(Sigma.0, mu.0, transpose = TRUE) + devs)\n\n  n.burn <- floor(n.mcmc / 10)\n  fort.raster.batch <- matrix(0, ncells, t)   \n\n  tHX.list <- vector('list', length = t) # speeds up computation by not calculating each MCMC step\n  HX.list <- vector('list', length = t)\n  for(s in 1:t){\n  \tHX.list[[s]] <-   X[H.list[[s]], ]\n  \ttHX.list[[s]] <- t(HX.list[[s]])\n  }\n  \n  ##\n  ## Initialize Storage\n  ##\n  \n  beta.save <- array(dim = c(tau, t, n.mcmc))\n  sigma.squared.beta.save <- vector(length = n.mcmc)\n  sigma.squared.epsilon.save <- vector(length = n.mcmc)\n  sigma.squared.eta.save <- vector(length = n.mcmc)\n\tphi.save <- vector(length = n.mcmc) \n  mu.beta.save <- matrix(NA, nrow = tau, ncol = n.mcmc)\n  fort.raster <- matrix(0, nrow = ncells, ncol = t)\n  MSPE.save <- 0\n  var.save <- matrix(0, nrow = ncells, ncol = t)\n  var.save.temp <- array(dim = c(100, ncells, t))\n  phi.accept <- 0  \n  eta.accept <- 0\n  epsilon.accept <- 0\n  \n  ##\n  ## Begin MCMC loop\n  ##\n\n\tfor(k in 1:n.mcmc){\n    if(k %% 100 == 0) cat(\" \", k) \n\n  \t##\n  \t## Sample Beta\n  \t##\n  \t\n  \tfor(s in 1:t){\n      devs <- rnorm(tau)\n      beta.A.chol <- if(is.null(dim(H.list[[s]])) == TRUE){\n        chol(tHX.list[[s]] %*% Sigma.inv[[s]] %*% HX.list[[s]] + Sigma.beta.inv)\n      } else {\n        chol(tHX.list[[s]] %*% Sigma.inv[[s]] %*% HX.list[[s]] + Sigma.beta.inv)\n      }\n      beta.b <- if(is.null(dim(H.list[[s]])) == TRUE){\n        tHX.list[[s]] %*% Sigma.inv[[s]] %*% Y.list[[s]] + Sigma.beta.inv %*% mu.beta\n      } else {\n        tHX.list[[s]] %*% Sigma.inv[[s]] %*% Y.list[[s]] + Sigma.beta.inv %*% mu.beta\n      }\n      beta[, s] <- backsolve(beta.A.chol, backsolve(beta.A.chol, beta.b, transpose = TRUE) + devs)\n  \t}\n  \t\n  \t##\n  \t## Sample mu.beta\n  \t##\n  \t\n  \tdevs <- rnorm(tau)\n  \tmu.beta.A.chol <- chol(t * Sigma.beta.inv + Sigma.0.inv)\n  \tmu.beta.b <- apply(Sigma.beta.inv %*% beta, 1, sum) + Sigma.0.inv %*% mu.0\n  \tmu.beta <- backsolve(mu.beta.A.chol, backsolve(mu.beta.A.chol, mu.beta.b, transpose = TRUE) + devs)\n  \n  \t##\n  \t## Sample sigma.squared.beta\n  \t##\n  \t\n    sigma.squared.beta <- 1 / rgamma(1, alpha.beta + 1 / 2 * nt.sum, beta.beta + 1 / 2 * make.sum.sigma.beta(beta, mu.beta))  \n  \tSigma.beta <- sigma.squared.beta * diag(tau)\n  \tSigma.beta.inv <- solve(Sigma.beta)\n  \t\n  \t##\n    ## Sample sigma.squared.eta\n    ##\n  \t\n  \tsigma.squared.eta.star <- rnorm(1, sigma.squared.eta, sigma.squared.eta.tune)\n    if(sigma.squared.eta.star > 0){\n      R.list.star <- lapply(1:t, make.R.list, sigma.squared.eta = sigma.squared.eta.star, phi = phi, D.list = D.list)\n      Sigma.star <- lapply(1:t, make.Sigma, R.list = R.list.star, Sigma.epsilon = Sigma.epsilon)\n      Sigma.star.inv <- lapply(1:t, make.Sigma.inv, Sigma = Sigma.star)\n      mh.eta.1 <- sum(sapply(1:t, make.mh, beta = beta, Sigma = Sigma.star, Sigma.inv = Sigma.star.inv)) + dinvgamma(sigma.squared.eta.star, alpha.eta, beta.eta, log = TRUE)\n      mh.eta.2 <- sum(sapply(1:t, make.mh, beta = beta, Sigma = Sigma, Sigma.inv = Sigma.inv)) + dinvgamma(sigma.squared.eta, alpha.eta, beta.eta, log = TRUE)\n      mh <- exp(mh.eta.1 - mh.eta.2)\n      \n      if(mh > runif(1)){\n        sigma.squared.eta <- sigma.squared.eta.star\n        Sigma <- Sigma.star\n        Sigma.inv <- Sigma.star.inv\n        eta.accept <- eta.accept + 1 / n.mcmc\n      }\n      rm(Sigma.star)\n      rm(Sigma.star.inv)\n    }\n    rm(sigma.squared.eta.star)\n  \t\n  \t##\n  \t## Sample sigma.squared.epsilon\n  \t##\n  \t\n    sigma.squared.epsilon.star <- rnorm(1, sigma.squared.epsilon, sigma.squared.epsilon.tune)\n    if(sigma.squared.epsilon.star > 0){\n      Sigma.epsilon.star <- lapply(1:t, make.Sigma.epsilon, sigma.squared.epsilon = sigma.squared.epsilon.star, I.nt = I.nt)\n      Sigma.epsilon.star.inv <- lapply(1:t, make.Sigma.epsilon.inv, sigma.squared.epsilon = sigma.squared.epsilon, I.nt = I.nt)\n      Sigma.star <- lapply(1:t, make.Sigma, R.list = R.list, Sigma.epsilon = Sigma.epsilon.star)\n      Sigma.star.inv <- lapply(1:t, make.Sigma.inv, Sigma = Sigma.star)\n      mh.epsilon.1 <-\tsum(sapply(1:t, make.mh, beta = beta, Sigma = Sigma.star, Sigma.inv = Sigma.star.inv)) + dinvgamma(sigma.squared.epsilon.star, alpha.epsilon, beta.epsilon, log = TRUE)\n      mh.epsilon.2 <- sum(sapply(1:t, make.mh, beta = beta, Sigma = Sigma, Sigma.inv = Sigma.inv)) + dinvgamma(sigma.squared.epsilon, alpha.epsilon, beta.epsilon, log = TRUE)\n      mh.epsilon <- exp(mh.epsilon.1 - mh.epsilon.2)\n  \t  \t\n  \t  if(mh.epsilon > runif(1)){\n        sigma.squared.epsilon <- sigma.squared.epsilon.star\n  \t    Sigma.epsilon <- Sigma.epsilon.star\n  \t  \tSigma.epsilon.inv <- Sigma.epsilon.star.inv\n  \t  \tSigma <- Sigma.star\n  \t    Sigma.inv <- Sigma.star.inv\n        epsilon.accept <- epsilon.accept + 1 / n.mcmc\n  \t  }\n  \t  rm(Sigma.epsilon.star)\n  \t  rm(Sigma.epsilon.star.inv)\n    \trm(Sigma.star)\n    \trm(Sigma.star.inv)\n  \t}\n    rm(sigma.squared.epsilon.star)\n  \t\n  \t##\n  \t## Sample phi\n  \t##\n  \t\n    phi.star <- rnorm(1, phi, phi.tune)\n  \tif(phi.star > 0){\n      R.list.star <- lapply(1:t, make.R.list, sigma.squared.eta = sigma.squared.eta, phi = phi.star, D.list = D.list)\t  \n  \t  Sigma.star <- lapply(1:t, make.Sigma, R.list = R.list.star, Sigma.epsilon = Sigma.epsilon)\n  \t  Sigma.star.inv <- lapply(1:t, make.Sigma.inv, Sigma = Sigma.star)\n      mh.phi.1 <-\tsum(sapply(1:t, make.mh, beta = beta, Sigma = Sigma.star, Sigma.inv = Sigma.star.inv)) + dinvgamma(phi.star, alpha.phi, beta.phi, log = TRUE)\n  \t\tmh.phi.2 <- sum(sapply(1:t, make.mh, beta = beta, Sigma = Sigma, Sigma.inv = Sigma.inv)) + dinvgamma(phi, alpha.phi, beta.phi, log = TRUE)\n  \t\tmh.phi <- exp(mh.phi.1 - mh.phi.2)\n  \t\t  \t\t\n  \tif(mh.phi > runif(1)){\n      phi <- phi.star\n      R.list <- R.list.star\n      Sigma <- Sigma.star\n      Sigma.inv <- Sigma.star.inv\n      phi.accept <- phi.accept + 1 / n.mcmc\n  \t}\n    rm(R.list.star)\n    rm(Sigma.star)\n    rm(Sigma.star.inv)\n  }\n  rm(phi.star)\n    \n  \t\n  ##\n  ## Simulate random field\n  ##\n    \n  if(k > n.burn){\n    if(k %% 100 == 0){\n      for(s in 1:t){\n        var.save[, s] <- var.save[, s] + apply(var.save.temp[, , s], 2, var) / ((n.mcmc - n.burn) / 100)\n        fort.raster.batch <- matrix(0, ncells, t)\n      }\n      var.save.temp <- array(0, dim = c(100, ncells, t))\n    }\n    Sigma.full <- (sigma.squared.eta * exp( - D / phi) + sigma.squared.beta * diag(ncells))\n    chol.Sigma <- chol(Sigma.full)\n    fort.raster <- fort.raster + (1 / (n.mcmc - n.burn)) * sapply(1:t, make.fort.batch, beta = beta, chol.Sigma = chol.Sigma, ncells = ncells)\n    var.save.temp[k %% 100 + 1, , ] <- fort.raster\n  }\n\n  ##\n  ## Save variables\n  ## \n  \n  beta.save[, , k] <- beta\n  sigma.squared.beta.save[k] <- sigma.squared.beta\n  sigma.squared.eta.save[k] <- sigma.squared.eta\n  sigma.squared.epsilon.save[k] <- sigma.squared.epsilon\n  mu.beta.save[, k] <- mu.beta  \n  phi.save[k] <- phi\t\n  }\n  \n##\n## Write output\n##\n  \nlist(beta.save = beta.save, sigma.squared.beta.save = sigma.squared.beta.save, sigma.squared.epsilon.save = sigma.squared.epsilon.save, sigma.squared.eta.save = sigma.squared.eta.save, mu.beta.save = mu.beta.save, n.mcmc = n.mcmc, fort.raster = fort.raster, phi.accept = phi.accept, eta.accept = eta.accept, epsilon.accept = epsilon.accept, phi.save = phi.save, var.save = var.save)#, MSPE.save = MSPE.save)\n}\n<<<<<<< HEAD\n\n##\n## Predictive Process\n##\n\n##  make.mh <- function(s, beta, Sigma.epsilon, Sigma.epsilon.inv, Sigma.inv, C.star, C.star.inv, c){\n##    ( - t / 2) * (determinant(C.star.inv + c %*% t(H[[s]]) %*% Sigma.epsilon.inv[[s]] %*% H[[s]] %*% t(c), logarithm = TRUE)$modulus[1] + \n##      determinant(C.star, logarithm = TRUE)$modulus[1] + determinant(Sigma.epsilon[[s]], logarithm = TRUE)$modulus[1]) - \n ##     1 / 2 * t(Y.list[[s]] - H[[s]] %*% X %*% beta[, s]) %*% (Sigma.inv[[s]]) %*% (Y.list[[s]] - H[[s]] %*% X %*% beta[, s])\n##  }\n\n##  make.c <- function(sigma.squared.eta, phi){\n##    sigma.squared.eta * exp( - D.0 / phi)\n##  }\n  \n##  make.C.star <- function(sigma.squared.eta, phi){\n##    sigma.squared.eta * exp( - D.star / phi)\n##  }\n  \n##  make.C.star.inv <- function(C.star){\n##    solve(C.star)\n##  }\n\n##  make.Sigma <- function(s, Sigma.epsilon, C.star, c){\n##  \tH[[s]] %*% t(c) %*% C.star %*% c %*% t(H[[s]]) + Sigma.epsilon[[s]]\n##  }\n  \n##  make.Sigma.inv <- function(s, Sigma.epsilon.inv, C.star.inv, c){\n##    Sigma.epsilon.inv[[s]] - Sigma.epsilon.inv[[s]] %*% H[[s]] %*% t(c) %*% solve(C.star.inv + c %*% t(H[[s]]) %*% Sigma.epsilon.inv[[s]] %*% H[[s]] %*% t(c)) %*% c %*% t(H[[s]]) %*% Sigma.epsilon.inv[[s]]\n##  }\n\n##  make.Sigma.inv <- function(s, Sigma.epsilon.inv, C.star.inv, c){\n## \tSigma.epsilon.inv[[s]] - Sigma.epsilon.inv[[s]] %*% H[[s]] %*% t(c) %*% solve(C.star.inv + c %*% t(H[[s]]) %*% Sigma.epsilon.inv[[s]] %*% H[[s]] %*% t(c)) %*% c %*% t(H[[s]]) %*% Sigma.epsilon.inv[[s]]\n## }\n\n#  make.vector <- function(s, beta, Sigma.inv){\n#    t(Y.list[[s]] - H[[s]] %*% X %*% beta[, s]) %*% (Sigma.inv[[s]]) %*% (Y.list[[s]] - H[[s]] %*% X %*% beta[, s])\n#  }\n\n#  make.Sigma.beta.det <- function(s, sigma.squared.beta, tau){\n#    (1 / sigma.squared.beta)^tau\n#  }\n\n## Predictive Process\n##  make.fort.batch <- function(s, beta, c, C.star, C.star.inv, sigma.squared.epsilon){#, w.tilde){\n##    w.star <- rmvnorm(1, vec.0, C.star)\n##    w.tilde <- t(c) %*% C.star.inv %*% t(w.star)\n##  \tif(dim(beta)[1] == 1){\n##  \t\tX * beta[s] + w.tilde + rnorm(ncells, 0, sigma.squared.epsilon)\n##  \t} else {\n##  \t\tX %*% beta[, s] + w.tilde + rnorm(ncells, 0, sigma.squared.epsilon)\n##  \t}\n##  }\n\n##  Distance Matrices for Predictive Process\n##  D.star <- as.matrix(dist(s.star))\n##  D.0 <- matrix(nrow = n.knots, ncol = ncells)\n##    for(i in 1:n.knots){\n##    for(j in 1:ncells){\n##      D.0[i, j] <- sqrt((s.star[i] - locs[j])^2)\n##  }\n##  }\n##  vec.0 <- rep(0, n.knots)\n##  C.star <- make.C.star(sigma.squared.eta = sigma.squared.eta, phi = phi)\n##  w.star <- rmvnorm(1, vec.0, C.star)\n##  C.star.inv <- make.C.star.inv(C.star)\n##  c <- \tmake.c(sigma.squared.eta, phi)\n##  Sigma <- vector('list', length = t)\n##  Sigma.inv <- vector('list', length = t)\n##  Sigma <- lapply(1:t, make.Sigma, Sigma.epsilon = Sigma.epsilon, C.star = C.star, c = c) \n##  Sigma.inv <- lapply(1:t, make.Sigma.inv, Sigma.epsilon.inv = Sigma.epsilon.inv, C.star.inv = C.star.inv, c = c)\n\n## Predictive Process\n=======\n\n##\n## Predictive Process\n##\n\n##  make.mh <- function(s, beta, Sigma.epsilon, Sigma.epsilon.inv, Sigma.inv, C.star, C.star.inv, c){\n##    ( - t / 2) * (determinant(C.star.inv + c %*% t(H[[s]]) %*% Sigma.epsilon.inv[[s]] %*% H[[s]] %*% t(c), logarithm = TRUE)$modulus[1] + \n##      determinant(C.star, logarithm = TRUE)$modulus[1] + determinant(Sigma.epsilon[[s]], logarithm = TRUE)$modulus[1]) - \n ##     1 / 2 * t(Y.list[[s]] - H[[s]] %*% X %*% beta[, s]) %*% (Sigma.inv[[s]]) %*% (Y.list[[s]] - H[[s]] %*% X %*% beta[, s])\n##  }\n\n##  make.c <- function(sigma.squared.eta, phi){\n##    sigma.squared.eta * exp( - D.0 / phi)\n##  }\n  \n##  make.C.star <- function(sigma.squared.eta, phi){\n##    sigma.squared.eta * exp( - D.star / phi)\n##  }\n  \n##  make.C.star.inv <- function(C.star){\n##    solve(C.star)\n##  }\n\n##  make.Sigma <- function(s, Sigma.epsilon, C.star, c){\n##  \tH[[s]] %*% t(c) %*% C.star %*% c %*% t(H[[s]]) + Sigma.epsilon[[s]]\n##  }\n  \n##  make.Sigma.inv <- function(s, Sigma.epsilon.inv, C.star.inv, c){\n##    Sigma.epsilon.inv[[s]] - Sigma.epsilon.inv[[s]] %*% H[[s]] %*% t(c) %*% solve(C.star.inv + c %*% t(H[[s]]) %*% Sigma.epsilon.inv[[s]] %*% H[[s]] %*% t(c)) %*% c %*% t(H[[s]]) %*% Sigma.epsilon.inv[[s]]\n##  }\n\n##  make.Sigma.inv <- function(s, Sigma.epsilon.inv, C.star.inv, c){\n## \tSigma.epsilon.inv[[s]] - Sigma.epsilon.inv[[s]] %*% H[[s]] %*% t(c) %*% solve(C.star.inv + c %*% t(H[[s]]) %*% Sigma.epsilon.inv[[s]] %*% H[[s]] %*% t(c)) %*% c %*% t(H[[s]]) %*% Sigma.epsilon.inv[[s]]\n## }\n\n#  make.vector <- function(s, beta, Sigma.inv){\n#    t(Y.list[[s]] - H[[s]] %*% X %*% beta[, s]) %*% (Sigma.inv[[s]]) %*% (Y.list[[s]] - H[[s]] %*% X %*% beta[, s])\n#  }\n\n#  make.Sigma.beta.det <- function(s, sigma.squared.beta, tau){\n#    (1 / sigma.squared.beta)^tau\n#  }\n\n## Predictive Process\n##  make.fort.batch <- function(s, beta, c, C.star, C.star.inv, sigma.squared.epsilon){#, w.tilde){\n##    w.star <- rmvnorm(1, vec.0, C.star)\n##    w.tilde <- t(c) %*% C.star.inv %*% t(w.star)\n##  \tif(dim(beta)[1] == 1){\n##  \t\tX * beta[s] + w.tilde + rnorm(ncells, 0, sigma.squared.epsilon)\n##  \t} else {\n##  \t\tX %*% beta[, s] + w.tilde + rnorm(ncells, 0, sigma.squared.epsilon)\n##  \t}\n##  }\n\n##  Distance Matrices for Predictive Process\n##  D.star <- as.matrix(dist(s.star))\n##  D.0 <- matrix(nrow = n.knots, ncol = ncells)\n##    for(i in 1:n.knots){\n##    for(j in 1:ncells){\n##      D.0[i, j] <- sqrt((s.star[i] - locs[j])^2)\n##  }\n##  }\n##  vec.0 <- rep(0, n.knots)\n##  C.star <- make.C.star(sigma.squared.eta = sigma.squared.eta, phi = phi)\n##  w.star <- rmvnorm(1, vec.0, C.star)\n##  C.star.inv <- make.C.star.inv(C.star)\n##  c <- \tmake.c(sigma.squared.eta, phi)\n##  Sigma <- vector('list', length = t)\n##  Sigma.inv <- vector('list', length = t)\n##  Sigma <- lapply(1:t, make.Sigma, Sigma.epsilon = Sigma.epsilon, C.star = C.star, c = c) \n##  Sigma.inv <- lapply(1:t, make.Sigma.inv, Sigma.epsilon.inv = Sigma.epsilon.inv, C.star.inv = C.star.inv, c = c)\n\n## Predictive Process\n>>>>>>> 1cdf65f5ac5f5995189ea691d26bbae58da0f0ff\n##    sigma.squared.eta.star <- rnorm(1, sigma.squared.eta, sigma.squared.eta.tune)\n##  \tif(sigma.squared.eta.star > 0){\n##      c.star <- make.c(sigma.squared.eta = sigma.squared.eta.star, phi = phi)\n##    \tC.star.star <- make.C.star(sigma.squared.eta = sigma.squared.eta.star, phi = phi)\n##      C.star.star.inv <- make.C.star.inv(C.star = C.star.star)\n##    \tSigma.star <- lapply(1:t, make.Sigma, Sigma.epsilon = Sigma.epsilon, C.star = C.star.star, c = c.star)\n##    \tSigma.star.inv <- lapply(1:t, make.Sigma.inv,  Sigma.epsilon = Sigma.epsilon, C.star.inv = C.star.star.inv, c = c.star)\n##  \t  mh.eta.1 <-\tsum(sapply(1:t, make.mh, beta = beta, Sigma.epsilon = Sigma.epsilon, Sigma.epsilon.inv = Sigma.epsilon.inv, Sigma.inv = Sigma.star.inv, C.star = C.star.star, C.star.inv = C.star.star.inv, c = c.star)) + dinvgamma(sigma.squared.eta.star, alpha.eta, beta.eta, log = TRUE)\n##    \tmh.eta.2 <- sum(sapply(1:t, make.mh, beta = beta, Sigma.epsilon = Sigma.epsilon, Sigma.epsilon.inv = Sigma.epsilon.inv, Sigma.inv = Sigma.inv, C.star = C.star, C.star.inv = C.star.inv, c = c)) + dinvgamma(sigma.squared.eta, alpha.eta, beta.eta, log = TRUE)\n##    \tmh.eta <- exp(mh.eta.1 - mh.eta.2)\n##  \t  \t\n##  \t  if(mh.eta > runif(1)){\n##        sigma.squared.eta <- sigma.squared.eta.star\n##        c <- c.star\n##        C.star <- C.star.star\n##        C.star.inv <- C.star.star.inv\n##        Sigma <- Sigma.star\n##        Sigma.inv <- Sigma.star.inv\n##        eta.accept <- eta.accept + 1 / n.mcmc\n##      }\n##    rm(c.star)\n##    rm(C.star.star)\n##    rm(C.star.star.inv)\n##    rm(Sigma.star)\n##    rm(Sigma.star.inv)\n##    }\n##  rm(sigma.squared.eta.star)\n\n## Predictive Process    \n##    sigma.squared.epsilon.star <- rnorm(1, sigma.squared.epsilon, sigma.squared.epsilon.tune)\n##  \tif(sigma.squared.epsilon.star > 0){\n##    \tSigma.epsilon.star <- lapply(1:t, make.Sigma.epsilon, sigma.squared.epsilon = sigma.squared.epsilon.star)\n##    \tSigma.epsilon.star.inv <- lapply(1:t, make.Sigma.epsilon.inv, Sigma.epsilon = Sigma.epsilon.star)\n##    \tSigma.star <- lapply(1:t, make.Sigma, Sigma.epsilon = Sigma.epsilon.star, C.star = C.star, c = c)\n##    \tSigma.star.inv <- lapply(1:t, make.Sigma.inv,  Sigma.epsilon = Sigma.epsilon.star, C.star.inv = C.star.inv, c = c)\n##  \t  mh.epsilon.1 <-\tsum(sapply(1:t, make.mh, beta = beta, Sigma.epsilon = Sigma.epsilon.star, Sigma.epsilon.inv = Sigma.epsilon.star.inv, Sigma.inv = Sigma.star.inv, C.star = C.star, C.star.inv = C.star.inv, c = c)) + dinvgamma(sigma.squared.epsilon.star, alpha.epsilon, beta.epsilon, log = TRUE)\n##    \tmh.epsilon.2 <- sum(sapply(1:t, make.mh, beta = beta, Sigma.epsilon = Sigma.epsilon, Sigma.epsilon.inv = Sigma.epsilon.inv, Sigma.inv = Sigma.inv, C.star = C.star, C.star.inv = C.star.inv, c = c)) + dinvgamma(sigma.squared.epsilon, alpha.epsilon, beta.epsilon, log = TRUE)\n##    \tmh.epsilon <- exp(mh.epsilon.1 - mh.epsilon.2)\n##  \t\n##  \t  if(mh.epsilon > runif(1)){\n##    \t\tsigma.squared.epsilon <- sigma.squared.epsilon.star\n##    \t\tSigma.epsilon <- Sigma.epsilon.star\n##  \t  \tSigma.epsilon.inv <- Sigma.epsilon.star.inv\n##  \t\t  Sigma <- Sigma.star\n##    \t\tSigma.inv <- Sigma.star.inv\n##    \t\tepsilon.accept <- epsilon.accept + 1 / n.mcmc\n##  \t  }\n##    rm(Sigma.epsilon.star)\n##    rm(Sigma.epsilon.star.inv)\n##    rm(Sigma.star)\n##    rm(Sigma.star.inv)\n##  \t}\n##  rm(sigma.squared.epsilon.star)\n\n## Predictive Process\n##    phi.star <- rnorm(1, phi, phi.tune)\n##  \tif(phi.star > 0){\n##  \t  c.star <- make.c(sigma.squared.eta = sigma.squared.eta, phi = phi.star)\n##  \t  C.star.star <- make.C.star(sigma.squared.eta = sigma.squared.eta, phi = phi.star)\n##  \t  C.star.star.inv <- make.C.star.inv(C.star = C.star.star)\n##  \t  Sigma.star <- lapply(1:t, make.Sigma, Sigma.epsilon = Sigma.epsilon, C.star = C.star.star, c = c.star)\n##  \t  Sigma.star.inv <- lapply(1:t, make.Sigma.inv,  Sigma.epsilon = Sigma.epsilon, C.star.inv = C.star.star.inv, c = c.star)\n##  \t  mh.phi.1 <-\tsum(sapply(1:t, make.mh, beta = beta, Sigma.epsilon = Sigma.epsilon, Sigma.epsilon.inv = Sigma.epsilon.inv, Sigma.inv = Sigma.star.inv, C.star = C.star.star, C.star.inv = C.star.star.inv, c = c.star)) + dinvgamma(phi.star, alpha.phi, beta.phi, log = TRUE)\n##  \t  mh.phi.2 <- sum(sapply(1:t, make.mh, beta = beta, Sigma.epsilon = Sigma.epsilon, Sigma.epsilon.inv = Sigma.epsilon.inv, Sigma.inv = Sigma.inv, C.star = C.star, C.star.inv = C.star.inv, c = c)) + dinvgamma(phi, alpha.phi, beta.phi, log = TRUE)\n##  \t  mh.phi <- exp(mh.phi.1 - mh.phi.2)\n##  \t  \n##  \t  if(mh.phi > runif(1)){\n##  \t    phi <- phi.star\n##  \t    c <- c.star\n##  \t    C.star <- C.star.star\n##  \t    C.star.inv <- C.star.star.inv\n##  \t    Sigma <- Sigma.star\n##  \t    Sigma.inv <- Sigma.star.inv\n##  \t    phi.accept <- phi.accept + 1 / n.mcmc\n##  \t  }\n##  \t  rm(c.star)\n##  \t  rm(C.star.star)\n##  \t  rm(C.star.star.inv)\n##  \t  rm(Sigma.star)\n##  \t  rm(Sigma.star.inv)\n##  \t}\n##  \trm(phi.star)\n\n#  temp <- c()\n#  for(j in 1:t){\n#    if(is.null(H.list[[j]]) == FALSE){\n#      temp[j] <- (fort.raster[,j][H.list[[j]]] - y.val[,j][loc.id.val[[j]]])^2 \n#    }\n#  }\n#  MSPE.save <- MSPE.save + mean(na.omit(temp)) / (n.mcmc - n.burn)\n  \n## Predictive Process    \n##  if(k > n.burn){\n##    if(k %% 100 == 0){\n##      for(s in 1:t){\n##        var.save[, s] <- var.save[, s] + apply(var.save.temp[, , s], 2, var) / ((n.mcmc - n.burn) / 100)\n##        fort.raster.batch <- matrix(0, ncells, t)\n##      }\n##      var.save.temp <- array(0, dim = c(100, ncells, t))\n##    }\n##    fort.raster <- sapply(1:t, make.fort.batch, beta = beta, c = c, C.star = C.star, C.star.inv = C.star.inv, sigma.squared.epsilon = sigma.squared.epsilon)#, w.tilde = w.tilde)\n##    var.save.temp[k %% 100 + 1, , ] <- fort.raster\n##  }\n    \n#  temp <- c()\n#  for(j in 1:t){\n#    if(is.null(H.list[[j]]) == FALSE){\n#      temp[j] <- (fort.raster[,j][H.list[[j]]] - y.val[,j][loc.id.val[[j]]])^2 \n#    }\n#  }\n#  MSPE.save <- MSPE.save + mean(na.omit(temp)) / (n.mcmc - n.burn)\n",
    "created" : 1389765312844.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "2132179732",
    "id" : "B526A523",
    "lastKnownWriteTime" : 1389885848,
    "path" : "~/1dSpatialSim/mcmc.spatial.R",
    "project_path" : "mcmc.spatial.R",
    "properties" : {
    },
    "source_on_save" : false,
    "type" : "r_source"
}